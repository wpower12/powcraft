/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/traffic/car.js":
/*!*******************************!*\
  !*** ./src/js/traffic/car.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Car = function Car(id, cardata, type) {\n  _classCallCheck(this, Car);\n\n  this.id = id;\n  this.loc = {\n    lane: cardata.lane,\n    pos: cardata.pos\n  };\n  this.type = type;\n  this.speed = cardata.speed;\n  this.timer = 0;\n};\n\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Car);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/car.js?");

/***/ }),

/***/ "./src/js/traffic/colorpicker.js":
/*!***************************************!*\
  !*** ./src/js/traffic/colorpicker.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ColorPicker = function ColorPicker(n) {\n  _classCallCheck(this, ColorPicker);\n\n  this.s = 90;\n  this.l = 40;\n  this.delta = 360 / n;\n};\n\n;\n$.extend(ColorPicker.prototype, {\n  //Returns the css color string used by canvas\n  get: function get(c) {\n    var ret = 'hsl(' + c * this.delta + ',' + this.s + '%,' + this.l + '%' + ')';\n    return ret;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorPicker);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/colorpicker.js?");

/***/ }),

/***/ "./src/js/traffic/inputhandler.js":
/*!****************************************!*\
  !*** ./src/js/traffic/inputhandler.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _road_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./road.js */ \"./src/js/traffic/road.js\");\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intersection.js */ \"./src/js/traffic/intersection.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar DRIVERS = [\"Normal\", \"Slow\", \"Crazy\"];\n\nvar InputHandler = /*#__PURE__*/function () {\n  function InputHandler(sim) {\n    _classCallCheck(this, InputHandler);\n\n    this.sim = sim;\n    this.btn_car = document.getElementById('btn-car');\n    this.btn_road = document.getElementById('btn-road');\n    this.btn_inter = document.getElementById('btn-inter');\n    this.btn_sim = document.getElementById('btn-sim');\n    this.btn_connect = document.getElementById('btn-connect');\n    this.btn_delete = document.getElementById('btn-delete');\n    this.el_ctrl_car = document.getElementById('car-toolbar');\n    this.el_ctrl_road = document.getElementById('road-toolbar');\n    this.el_ctrl_inter = document.getElementById('inter-toolbar');\n    this.el_ctrl_sim = document.getElementById('sim-toolbar');\n    this.$speed = document.getElementById('car-in-speed');\n    this.$color = document.getElementById('car-in-color');\n    this.$roadlanes = document.getElementById('road-in-lanes');\n    this.$roador = document.getElementById('road-in-orient');\n    this.$length = document.getElementById('road-in-length');\n    this.$intlanes = document.getElementById('inter-in-lanes'); //Drawing/Adding fields\n\n    this.selected = 0; //0 - Car, 1 - Road, 2 - Intersection, 3 - Connection, 4 - Delete\n\n    this.mousecell = {\n      x: 0,\n      y: 0\n    };\n    this.mousecell = {\n      x: 0,\n      y: 0\n    };\n    this.timer = 0;\n    this.drawing = true; // Not sure wht i did it this way. \n\n    this.r = new _road_js__WEBPACK_IMPORTED_MODULE_0__.default({\n      x: 0,\n      y: 0\n    }, 0, 0, 0);\n    this.roadfits = true;\n    this.connclicked = false;\n    this.openroad = \"\";\n    this.openroadside = 0;\n    this.updateValues();\n    this.attachButtonListeners();\n    this.attachInputs();\n  }\n\n  _createClass(InputHandler, [{\n    key: \"attachButtonListeners\",\n    value: function attachButtonListeners() {\n      this.btn_car.addEventListener('click', function (e) {\n        this.el_ctrl_road.classList.add(\"hidden\");\n        this.el_ctrl_inter.classList.add(\"hidden\");\n        this.el_ctrl_sim.classList.add(\"hidden\");\n        this.el_ctrl_car.classList.remove(\"hidden\");\n        this.selected = 0;\n      }.bind(this));\n      this.btn_road.addEventListener('click', function (e) {\n        this.el_ctrl_car.classList.add(\"hidden\");\n        this.el_ctrl_inter.classList.add(\"hidden\");\n        this.el_ctrl_sim.classList.add(\"hidden\");\n        this.el_ctrl_road.classList.remove(\"hidden\");\n        this.selected = 1;\n      }.bind(this));\n      this.btn_inter.addEventListener('click', function (e) {\n        this.el_ctrl_car.classList.add(\"hidden\");\n        this.el_ctrl_road.classList.add(\"hidden\");\n        this.el_ctrl_sim.classList.add(\"hidden\");\n        this.el_ctrl_inter.classList.remove(\"hidden\");\n        this.selected = 2;\n      }.bind(this));\n      this.btn_sim.addEventListener('click', function (e) {\n        this.el_ctrl_road.classList.add(\"hidden\");\n        this.el_ctrl_inter.classList.add(\"hidden\");\n        this.el_ctrl_car.classList.add(\"hidden\");\n        this.el_ctrl_sim.classList.remove(\"hidden\");\n        this.selected = 3; // start on connect.\n      }.bind(this));\n      this.btn_connect.addEventListener('click', function (e) {\n        this.selected = 3;\n      }.bind(this));\n      this.btn_delete.addEventListener('click', function (e) {\n        this.selected = 4;\n      }.bind(this));\n    }\n  }, {\n    key: \"attachInputs\",\n    value: function attachInputs() {\n      //On mouse move to update data for drawing\n      this.sim.canvas.addEventListener('mousemove', function (e) {\n        this.mousepos = this.calculateMousePos(e);\n        this.mousecell = this.calculateMouseCell();\n        this.checkInsertionFit(); //This updates fields used by the click callbacks\n        //Reset Drawing timer\n\n        this.timer = 0;\n        this.drawing = true;\n      }.bind(this)); //On mouse click to add things\n\n      this.sim.canvas.addEventListener('click', function (e) {\n        this.updateValues();\n\n        switch (this.selected) {\n          case 0:\n            //Car\n            this.carClickCallback();\n            break;\n\n          case 1:\n            //Road\n            this.roadClickCallback();\n            break;\n\n          case 2:\n            //Intersection\n            this.interClickCallback();\n            break;\n\n          case 3:\n            //Connection\n            this.connClickCallback();\n            break;\n\n          case 4:\n            //Delete\n            this.deleteClickCallback();\n\n          default:\n        }\n      }.bind(this));\n    }\n  }, {\n    key: \"updateValues\",\n    value: function updateValues() {\n      this._speed = this.$speed.value;\n      this._color = this.$color.value;\n      this._roadlanes = this.$roadlanes.value;\n      this._length = this.$length.value;\n      this._intlanes = this.$intlanes.value;\n      this._roador = this.$roador.value;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.updateValues();\n      var ctx = this.sim.ctx;\n\n      if (this.mousecell.y >= 0 && this.mousecell.x >= 0 && this.mousecell.y < this.sim.size.y && this.mousecell.x < this.sim.size.x) {\n        switch (this.selected) {\n          case 0:\n            //Car\n            this.drawCar(ctx);\n            break;\n\n          case 1:\n            //Road\n            this.drawRoad(ctx);\n            break;\n\n          case 2:\n            //Intersections\n            this.drawInt(ctx);\n            break;\n\n          case 3:\n            //Connections\n            this.drawConn(ctx);\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"drawCar\",\n    value: function drawCar(ctx) {\n      if (++this.timer > 20) {\n        this.drawing = !this.drawing;\n        this.timer = 0;\n      }\n\n      if (this.drawing) {\n        ctx.beginPath();\n        ctx.fillStyle = \"grey\";\n        ctx.fillRect(this.mousecell.x * this.sim.scale + this.sim.size.x0 + 2, this.mousecell.y * this.sim.scale + this.sim.size.y0 + 2, this.sim.scale - 3, this.sim.scale - 3);\n      }\n    }\n  }, {\n    key: \"drawRoad\",\n    value: function drawRoad(ctx) {\n      if (this.drawing) {\n        //Draw the rectangle\n        var rx, ry, dx, dy, o, or;\n        o = this._roador;\n        or = this.r.getO(o * 1);\n        rx = (this.mousecell.x + or.xd) * this.sim.scale + this.sim.size.x0;\n        ry = (this.mousecell.y + or.yd) * this.sim.scale + this.sim.size.y0;\n        dx = (this._roadlanes * or.lx + this._length * or.px) * this.sim.scale - 1 * or.lx - 1 * or.px;\n        dy = (this._roadlanes * or.ly + this._length * or.py) * this.sim.scale - 1 * or.ly - 1 * or.py;\n        ctx.strokeStyle = \"grey\";\n        ctx.beginPath();\n        ctx.setLineDash([5]);\n        ctx.lineWidth = 3;\n        ctx.rect(rx, ry, dx, dy);\n        ctx.stroke();\n        ctx.setLineDash([0]); //Draw direction arrow\n\n        var mx, my, ax, ay, tx, ty;\n        mx = rx + 0.5 * this._roadlanes * this.sim.scale * or.lx;\n        my = ry + 0.5 * this._roadlanes * this.sim.scale * or.ly;\n        ax = mx + this._length * this.sim.scale * or.px;\n        ay = my + this._length * this.sim.scale * or.py;\n        ctx.strokeStyle = \"grey\";\n        ctx.beginPath();\n        ctx.moveTo(mx, my);\n        ctx.lineTo(ax, ay);\n        ctx.stroke();\n        ctx.beginPath();\n        tx = ax - this.sim.scale * or.px - 0.5 * this.sim.scale * or.lx;\n        ty = ay - this.sim.scale * or.py - 0.5 * this.sim.scale * or.ly;\n        ctx.moveTo(ax, ay);\n        ctx.lineTo(tx, ty);\n        ctx.moveTo(ax, ay);\n        tx = ax - this.sim.scale * or.px + 0.5 * this.sim.scale * or.lx;\n        ty = ay - this.sim.scale * or.py + 0.5 * this.sim.scale * or.ly;\n        ctx.lineTo(tx, ty);\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"drawInt\",\n    value: function drawInt(ctx) {\n      //Draw an outline of the square representing the intersection.\n      var rx, ry, d;\n      rx = (this.mousecell.x + 1) * this.sim.scale + this.sim.size.x0;\n      ry = (this.mousecell.y + 1) * this.sim.scale + this.sim.size.y0;\n      d = -1 * this._intlanes * this.sim.scale;\n      ctx.strokeStyle = \"grey\";\n      ctx.beginPath();\n      ctx.setLineDash([5]);\n      ctx.lineWidth = 3;\n      ctx.rect(rx, ry, d * 2, d * 2);\n      ctx.stroke();\n      ctx.setLineDash([0]);\n    }\n  }, {\n    key: \"drawConn\",\n    value: function drawConn(ctx) {\n      //Road Output Connections\n      var road;\n\n      for (var i = 0; i < this.sim.roads.length; i++) {\n        road = this.sim.roads[i];\n\n        if (!(road.out === \"none\")) {\n          this.drawConnLineRoad(ctx, road);\n        }\n\n        this.drawDirectionArrow(ctx, road);\n      } //Intersection Output Connections\n\n\n      var _int, outx0, outy0, inx0, iny0, dx, dy;\n\n      for (var i = 0; i < this.sim.intersections.length; i++) {\n        this.drawConnLineInt(ctx, this.sim.intersections[i]);\n      } //If an open output is clicked, draw a line from output to cursor\n\n\n      if (this.connclicked === true) {\n        this.drawMouseLine(ctx);\n      }\n    }\n  }, {\n    key: \"drawConnLineRoad\",\n    value: function drawConnLineRoad(ctx, road) {\n      var from, to;\n      from = {\n        x: (road.dim.xd0 + road.o.px * (road.length - 0.5) + 0.5 * road.o.lx * road.lanes) * this.sim.scale + this.sim.size.x0,\n        y: (road.dim.yd0 + road.o.py * (road.length - 0.5) + 0.5 * road.o.ly * road.lanes) * this.sim.scale + this.sim.size.y0\n      };\n      to = road.out.getTo(this.sim.size, this.sim.scale, road.outside);\n      ctx.beginPath();\n      ctx.strokeStyle = \"#B33D3D\";\n      ctx.lineWidth = 2;\n      ctx.moveTo(from.x, from.y);\n      ctx.lineTo(to.x, to.y);\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawConnLineInt\",\n    value: function drawConnLineInt(ctx, _int2) {\n      for (var side = 0; side < 4; side++) {\n        if (!(_int2.outs[side] === \"none\")) {\n          this.drawOutLineInt(ctx, _int2, side);\n        } else {\n          this.drawOutputsInt(ctx, _int2, side);\n        }\n      }\n    }\n  }, {\n    key: \"drawDirectionArrow\",\n    value: function drawDirectionArrow(ctx, road) {\n      //Draw direction arrow\n      var mx, my, ax, ay, tx, ty;\n      ax = road.dim.xd0 + 0.5 * road.length * road.o.px + 0.5 * road.o.lx * road.lanes;\n      ay = road.dim.yd0 + 0.5 * road.length * road.o.py + 0.5 * road.o.ly * road.lanes;\n      ctx.strokeStyle = \"#B33D3D\";\n      ctx.beginPath();\n      tx = (ax - 0.5 * road.o.lx - 0.5 * road.o.px) * this.sim.scale;\n      ty = (ay - 0.5 * road.o.ly - 0.5 * road.o.py) * this.sim.scale;\n      ctx.moveTo(ax * this.sim.scale + this.sim.size.x0, ay * this.sim.scale + this.sim.size.y0);\n      ctx.lineTo(tx + this.sim.size.x0, ty + this.sim.size.y0);\n      ctx.moveTo(ax * this.sim.scale + this.sim.size.x0, ay * this.sim.scale + this.sim.size.y0);\n      tx = (ax + 0.5 * road.o.lx - 0.5 * road.o.px) * this.sim.scale;\n      ty = (ay + 0.5 * road.o.ly - 0.5 * road.o.py) * this.sim.scale;\n      ctx.lineTo(tx + this.sim.size.x0, ty + this.sim.size.y0);\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawMouseLine\",\n    value: function drawMouseLine(ctx, road) {\n      var from = this.openroad.getFrom(this.sim.size, this.sim.scale, this.openroadside);\n      ctx.beginPath();\n      ctx.strokeStyle = \"#B33D3D\";\n      ctx.moveTo(from.x, from.y);\n      ctx.lineTo(this.mousepos.x, this.mousepos.y);\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawOutputsInt\",\n    value: function drawOutputsInt(ctx, _int3, side) {\n      //Draw Rectangles\n      var outx0, outy0, inx0, iny0, dx, dy;\n\n      switch (side) {\n        case 0:\n          outx0 = _int3.base.x;\n          outy0 = _int3.base.y - 2 * _int3.lanes + 1;\n          inx0 = _int3.base.x - _int3.lanes + 1;\n          iny0 = _int3.base.y - 2 * _int3.lanes + 1;\n          dx = -1 * (_int3.lanes - 1);\n          dy = 1;\n          break;\n\n        case 1:\n          outx0 = _int3.base.x - 2 * _int3.lanes + 1;\n          outy0 = _int3.base.y - 2 * _int3.lanes + 2;\n          inx0 = outx0;\n          iny0 = _int3.base.y - _int3.lanes + 1;\n          ;\n          dx = 1;\n          dy = _int3.lanes - 1;\n          break;\n\n        case 2:\n          outx0 = _int3.base.x - 2 * _int3.lanes + 2;\n          outy0 = _int3.base.y;\n          inx0 = _int3.base.x - _int3.lanes + 1;\n          iny0 = outy0;\n          dx = _int3.lanes - 1;\n          dy = 1;\n          break;\n\n        case 3:\n          outx0 = _int3.base.x;\n          outy0 = _int3.base.y;\n          inx0 = outx0;\n          iny0 = _int3.base.y - _int3.lanes + 1;\n          dx = 1;\n          dy = -1 * (_int3.lanes - 1);\n          break;\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"#B33D3D\";\n      ctx.rect(outx0 * this.sim.scale + this.sim.size.x0, outy0 * this.sim.scale + this.sim.size.y0, dx * this.sim.scale, dy * this.sim.scale);\n      ctx.rect(inx0 * this.sim.scale + this.sim.size.x0, iny0 * this.sim.scale + this.sim.size.y0, dx * this.sim.scale, dy * this.sim.scale);\n      ctx.stroke();\n    }\n  }, {\n    key: \"drawOutLineInt\",\n    value: function drawOutLineInt(ctx, _int4, side) {\n      var from, to;\n      from = _int4.getFrom(this.sim.size, this.sim.scale, side);\n      to = _int4.outs[side].getTo(this.sim.size, this.sim.scale, side);\n      ctx.beginPath();\n      ctx.strokeStyle = \"#B33D3D\";\n      ctx.moveTo(from.x, from.y);\n      ctx.lineTo(to.x, to.y);\n      ctx.stroke();\n    }\n  }, {\n    key: \"carClickCallback\",\n    value: function carClickCallback() {\n      var mx, my;\n      mx = this.mousecell.x;\n      my = this.mousecell.y;\n\n      if (mx >= 0 && my >= 0 && mx < this.sim.size.x && my < this.sim.size.y) {\n        //Find which road or intersection the car goes in\n        for (var i = 0; i < this.sim.roads.length; i++) {\n          if (this.insideRoad(mx, my, this.sim.roads[i])) {\n            var target = this.sim.roads[i];\n            var pos = this.getPos(mx, my, target); //Check that it doesnt hit another car.\n\n            if (target.road[pos.l][pos.p] === 0) {\n              target.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_1__.default(this._color, {\n                lane: pos.l,\n                pos: pos.p,\n                speed: this._speed\n              }, Driver().NORMAL));\n            }\n\n            break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"roadClickCallback\",\n    value: function roadClickCallback() {\n      var mx, my;\n      mx = this.mousecell.x;\n      my = this.mousecell.y;\n\n      if (this.roadfits) {\n        // console.log(this._roador)\n        this.sim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_0__.default({\n          x: mx,\n          y: my\n        }, 1 * this._roador, this._length, this._roadlanes));\n      }\n    }\n  }, {\n    key: \"interClickCallback\",\n    value: function interClickCallback() {\n      var mx, my;\n      mx = this.mousecell.x;\n      my = this.mousecell.y;\n\n      if (this.roadfits) {\n        this.sim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({\n          x: mx,\n          y: my\n        }, this._intlanes, 0));\n      }\n    }\n  }, {\n    key: \"connClickCallback\",\n    value: function connClickCallback() {\n      var mx, my;\n      mx = this.mousecell.x;\n      my = this.mousecell.y;\n\n      if (this.connclicked) {\n        //Check if click is on a road\n        for (var i = 0; i < this.sim.roads.length; i++) {\n          if (this.insideRoad(mx, my, this.sim.roads[i])) {\n            var target = this.sim.roads[i];\n            this.openroad.setOutput(target, this.openroadside);\n            break;\n          }\n        } //Check if click is on an intersection\n\n\n        for (var i = 0; i < this.sim.intersections.length; i++) {\n          if (this.insideInt(mx, my, this.sim.intersections[i])) {\n            var target = this.sim.intersections[i];\n            this.openroad.setOutput(target, target.getSide(mx, my));\n            break;\n          }\n        }\n\n        this.connclicked = false;\n      } else {\n        //Check if click is on a connection\n        for (var i = 0; i < this.sim.roads.length; i++) {\n          if (this.insideRoad(mx, my, this.sim.roads[i])) {\n            this.sim.roads[i].out = \"none\";\n            this.openroad = this.sim.roads[i];\n            this.openroadside = 0; //Hack for road/intersection 'polymorphism'\n\n            break;\n          }\n        } //Check if click is on an intersection\n\n\n        var inter;\n\n        for (var i = 0; i < this.sim.intersections.length; i++) {\n          inter = this.sim.intersections[i];\n\n          if (this.insideInt(mx, my, inter)) {\n            inter.outs[inter.getOut(mx, my)] = \"none\";\n            this.openroad = inter;\n            this.openroadside = inter.getOut(mx, my);\n            break;\n          }\n        }\n\n        this.connclicked = true;\n      }\n    }\n  }, {\n    key: \"deleteClickCallback\",\n    value: function deleteClickCallback() {\n      var mx, my;\n      mx = this.mousecell.x;\n      my = this.mousecell.y;\n\n      for (var i = 0; i < this.sim.roads.length; i++) {\n        if (this.insideRoad(mx, my, this.sim.roads[i])) {\n          this.sim.roads.splice(i, 1);\n          break;\n        }\n      } //Check if click is on an intersection\n\n\n      for (var i = 0; i < this.sim.intersections.length; i++) {\n        if (this.insideInt(mx, my, this.sim.intersections[i])) {\n          this.sim.intersections.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"calculateMousePos\",\n    value: function calculateMousePos(event) {\n      var rect = this.sim.canvas.getBoundingClientRect();\n      var mx = event.clientX - rect.left;\n      var my = event.clientY - rect.top;\n      return {\n        x: mx,\n        y: my\n      };\n    }\n  }, {\n    key: \"calculateMouseCell\",\n    value: function calculateMouseCell() {\n      var mx = this.mousepos.x;\n      var my = this.mousepos.y;\n      mx = mx - this.sim.size.x0 - this.sim.scale / 4;\n      my = my - this.sim.size.y0 - this.sim.scale / 4;\n      mx = Math.floor(mx / this.sim.scale);\n      my = Math.floor(my / this.sim.scale);\n      return {\n        x: mx,\n        y: my\n      };\n    }\n  }, {\n    key: \"checkInsertionFit\",\n    value: function checkInsertionFit() {\n      var rx0, ry0, rxn, ryn, or, o, bottom, top, left, right;\n      rx0 = this.mousecell.x;\n      ry0 = this.mousecell.y;\n\n      switch (this.selected) {\n        case 1:\n          o = this._roador;\n          or = this.r.getO(o * 1);\n          rxn = rx0 + ((this._roadlanes - 1) * or.lx + (this._length - 1) * or.px);\n          ryn = ry0 + ((this._roadlanes - 1) * or.ly + (this._length - 1) * or.py);\n          top = Math.max(ry0, ryn);\n          bottom = Math.min(ry0, ryn);\n          left = Math.min(rx0, rxn);\n          right = Math.max(rx0, rxn);\n          break;\n\n        case 2:\n          rxn = rx0 - this._intlanes * 2 + 1;\n          ryn = ry0 - this._intlanes * 2 + 1;\n          top = Math.max(ry0, ryn);\n          bottom = Math.min(ry0, ryn);\n          left = Math.min(rx0, rxn);\n          right = Math.max(rx0, rxn);\n          break;\n\n        default:\n          break;\n      }\n\n      this.roadfits = true; //Bounding rect\n\n      if (top < this.sim.size.y && bottom >= 0 && left >= 0 && right < this.sim.size.x) {\n        var road, rtop, rbottom, rleft, rright;\n\n        for (var i = 0; i < this.sim.roads.length; i++) {\n          road = this.sim.roads[i];\n          rtop = Math.max(road.dim.yd0, road.dim.yd0 + road.dim.dy);\n          rbottom = Math.min(road.dim.yd0, road.dim.yd0 + road.dim.dy);\n          rright = Math.max(road.dim.xd0, road.dim.xd0 + road.dim.dx);\n          rleft = Math.min(road.dim.xd0, road.dim.xd0 + road.dim.dx); // l1 < r2 && r1 > l2 && b1 < t2 && t1 > b2\n\n          if (left < rright && right >= rleft && top >= rbottom && bottom < rtop) {\n            this.roadfits = false;\n            break;\n          }\n        }\n      } else {\n        this.roadfits = false;\n      }\n    }\n  }, {\n    key: \"insideRoad\",\n    value: function insideRoad(x, y, road) {\n      var right = Math.max(road.dim.xn0, road.dim.xn0 + road.o.lx * (road.lanes - 1) + road.o.px * (road.length - 1));\n      var left = Math.min(road.dim.xn0, road.dim.xn0 + road.o.lx * (road.lanes - 1) + road.o.px * (road.length - 1));\n      var top = Math.max(road.dim.yn0, road.dim.yn0 + road.o.ly * (road.lanes - 1) + road.o.py * (road.length - 1));\n      var bottom = Math.min(road.dim.yn0, road.dim.yn0 + road.o.ly * (road.lanes - 1) + road.o.py * (road.length - 1));\n      return x >= left && x <= right && y >= bottom && y <= top;\n    }\n  }, {\n    key: \"insideInt\",\n    value: function insideInt(x, y, _int5) {\n      var right = _int5.base.x;\n      var left = _int5.base.x - 2 * _int5.lanes;\n      var bottom = _int5.base.y - 2 * _int5.lanes;\n      var top = _int5.base.y;\n      var ret = x >= left && x <= right && y >= bottom && y <= top;\n      return ret;\n    }\n  }, {\n    key: \"getPos\",\n    value: function getPos(x, y, road) {\n      var lane, pos;\n      lane = Math.abs(road.o.lx * (road.dim.xn0 - x) + road.o.ly * (road.dim.yn0 - y)); //pos is distance in px/py from xn0/yn0\n\n      pos = Math.abs(road.o.px * (road.dim.xn0 - x) + road.o.py * (road.dim.yn0 - y));\n      return {\n        l: lane,\n        p: pos\n      };\n    }\n  }]);\n\n  return InputHandler;\n}();\n\n;\n\nfunction Driver() {\n  return {\n    NORMAL: 0,\n    SLOW: 1,\n    CRAZY: 2\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputHandler);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/inputhandler.js?");

/***/ }),

/***/ "./src/js/traffic/intersection.js":
/*!****************************************!*\
  !*** ./src/js/traffic/intersection.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar Intersection = /*#__PURE__*/function () {\n  //Base point is the lower right corner on the grid, in grid units\n  function Intersection(basepoint, lanecount, type) {\n    _classCallCheck(this, Intersection);\n\n    this.base = {\n      x: basepoint.x,\n      y: basepoint.y\n    };\n    this.lanes = lanecount;\n    this.type = type;\n    this.colors = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(7); //Sides basically are in's and out's, 4 of um\n\n    this.outs = []; //Point to roads\n\n    for (var i = 0; i < 4; i++) {\n      this.outs[i] = \"none\";\n    } //Fields needed for managing logic.\n\n\n    this.timer = 0;\n    this.threshold = 200;\n    this.currentside = 0; //Side 'in', same orientation as roads\n\n    this.cycle = 0;\n    this.outside = 1;\n    this.cars = [];\n    this.road = []; //Square road this time.  the side is a road, same as before\n    //Bottom right is 0,0, 'left turn' goes towards 2n,2n corner\n\n    for (var i = 0; i < this.lanes * 2; i++) {\n      this.road[i] = [];\n\n      for (var j = 0; j < this.lanes * 2; j++) {\n        this.road[i][j] = 0;\n      }\n    }\n  }\n\n  _createClass(Intersection, [{\n    key: \"update\",\n    value: function update() {\n      var side = this.currentside;\n      var out = (this.currentside + this.cycle + 1) % 4; // console.log(this.cars);\n      //Only do stuff/allow cars in if there is an output that way.\n\n      if (this.outs[out] !== \"none\") {\n        for (var c = 0; c < this.cars.length; c++) {\n          var car = this.cars[c];\n          car.timer++;\n\n          if (car.timer > car.speed) {\n            car.timer = 0;\n\n            switch (this.cycle) {\n              case 0:\n                //Right                            \n                this.updateCarRight(car, c);\n                break;\n\n              case 1:\n                //Straight\n                this.updateCarStraight(car, c);\n                break;\n\n              case 2:\n                //Left\n                this.updateCarLeft(car, c);\n                break;\n\n              default:\n                // console.log(\"hit default update for car in intersection.\");\n                break;\n            }\n          }\n        }\n      } else {\n        this.timer = this.threshold;\n      } //Increment timer, and change stuff if necessary\n\n\n      this.timer++;\n\n      if (this.timer >= this.threshold && this.cars.length === 0) {\n        this.cycle = Math.floor(Math.random() * 3);\n        this.currentside = (this.currentside + 1) % 4;\n        this.outside = (this.currentside + this.cycle + 1) % 4;\n        this.timer = 0; // console.log(\"changed state cs: \"+this.currentside+\" os: \"+this.outside);\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, size) {\n      this.drawPavement(ctx, size);\n      this.drawCars(ctx, size);\n    }\n  }, {\n    key: \"drawPavement\",\n    value: function drawPavement(ctx, size) {\n      //Grey square under the intersection\n      ctx.fillStyle = \"lightgrey\";\n      var x0 = size.scale * (this.base.x + 1) + size.x0;\n      var y0 = size.scale * (this.base.y + 1) + size.y0;\n      var d = -2 * size.scale * this.lanes;\n      ctx.beginPath();\n      ctx.rect(x0, y0, d, d);\n      ctx.fill();\n      ctx.strokeStyle = \"darkgrey\";\n      ctx.beginPath();\n      ctx.setLineDash([size.scale * this.lanes]);\n      ctx.lineWidth = 3;\n      ctx.rect(x0, y0, d, d);\n      ctx.stroke();\n      ctx.setLineDash([0]);\n    }\n  }, {\n    key: \"drawCars\",\n    value: function drawCars(ctx, size) {\n      //Need to draw cars based on road orientation.\n      var t = this.getDrawTransform(this.currentside); //Transform array position to draw position\n\n      var cloc = {\n        x: 0,\n        y: 0\n      };\n\n      for (var c = 0; c < this.cars.length; c++) {\n        var car = this.cars[c];\n        cloc.x = size.scale * (this.base.x + t.dbasex * (2 * this.lanes - 1) + t.lanex * car.loc.lane + t.posx * car.loc.pos) + size.x0;\n        cloc.y = size.scale * (this.base.y + t.dbasey * (2 * this.lanes - 1) + t.laney * car.loc.lane + t.posy * car.loc.pos) + size.y0;\n        ctx.beginPath();\n        ctx.fillStyle = this.colors.get(car.id);\n        ctx.fillRect(cloc.x + 2, cloc.y + 2, size.scale - 4, size.scale - 4);\n      }\n    }\n  }, {\n    key: \"addCar\",\n    value: function addCar(c, side) {\n      this.cars.push(c); //Based on side, need to add car to right location.\n\n      var l, p;\n      var n = this.lanes;\n      var lane = c.loc.lane;\n      c.loc.pos = 0;\n      this.road[lane][0] = c;\n    }\n  }, {\n    key: \"setOutput\",\n    value: function setOutput(r, s) {\n      this.outs[s] = r;\n    }\n  }, {\n    key: \"updateCarStraight\",\n    value: function updateCarStraight(car, c) {\n      var out = this.outs[this.outside];\n\n      if (car.loc.pos >= this.lanes * 2 - 1) {\n        this.passCar(out, car, car.loc.lane, c);\n      } else {\n        //Else, try to go straight\n        this.moveForward(car);\n      }\n    }\n  }, {\n    key: \"updateCarRight\",\n    value: function updateCarRight(car, c) {\n      var out = this.outs[this.outside]; // console.log(\"out\", out, \"cs\", this.currentside); \n      //Car goes straight until its in the diagonal, then right until out\n      //diagonal is when pos == lane\n\n      if (car.loc.lane === 0) {\n        this.passCar(out, car, car.loc.pos, c);\n      } else {\n        if (car.loc.pos >= car.loc.lane) {\n          this.moveRight(car);\n        } else {\n          //Else, try to go straight\n          this.moveForward(car);\n        }\n      }\n    }\n  }, {\n    key: \"updateCarLeft\",\n    value: function updateCarLeft(car, c) {\n      var out = this.outs[this.outside];\n\n      if (car.loc.lane === 2 * this.lanes - 1) {\n        //Try to pass car to output\n        var laneout = 2 * this.lanes - 1 - car.loc.pos;\n        this.passCar(out, car, laneout, c);\n      } else {\n        if (car.loc.pos <= 2 * this.lanes - car.loc.pos - car.loc.lane) {\n          this.moveForward(car);\n        } else {\n          this.moveLeft(car);\n        }\n      }\n    }\n  }, {\n    key: \"passCar\",\n    value: function passCar(out, car, laneout, c) {\n      if (out.open(laneout, 0)) {\n        out.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_0__.default(car.id, {\n          lane: laneout,\n          pos: 0,\n          speed: car.speed\n        }, car.type));\n        this.cars.splice(c, 1);\n        this.road[car.loc.lane][car.loc.pos] = 0;\n      }\n    }\n  }, {\n    key: \"moveForward\",\n    value: function moveForward(car) {\n      if (this.road[car.loc.lane][car.loc.pos + 1] === 0) {\n        this.road[car.loc.lane][car.loc.pos] = 0;\n        this.road[car.loc.lane][car.loc.pos + 1] = car;\n        car.loc.pos++;\n      } else {\n        car.timer = this.threshold;\n      }\n    }\n  }, {\n    key: \"moveRight\",\n    value: function moveRight(car) {\n      if (this.road[car.loc.lane - 1][car.loc.pos] === 0) {\n        this.road[car.loc.lane][car.loc.pos] = 0;\n        this.road[car.loc.lane - 1][car.loc.pos] = car;\n        car.loc.lane--;\n      } else {\n        car.timer = this.threshold;\n      }\n    }\n  }, {\n    key: \"moveLeft\",\n    value: function moveLeft(car) {\n      if (this.road[car.loc.lane + 1][car.loc.pos] === 0) {\n        this.road[car.loc.lane][car.loc.pos] = 0;\n        this.road[car.loc.lane + 1][car.loc.pos] = car;\n        car.loc.lane++;\n      } else {\n        car.timer = this.threshold;\n      }\n    }\n  }, {\n    key: \"open\",\n    value: function open(lane, side) {\n      //Need to use orientation of sides to do this in a less shitty way.\n      return side === this.currentside && this.road[lane][0] === 0 && this.outs[this.outside] != \"none\";\n    }\n  }, {\n    key: \"getSide\",\n    value: function getSide(mx, my) {\n      console.log(\"Inter getSide:\", mx, my); //Given mouse click, see what side its on.\n      //whichever quadrant its in. \n\n      if (mx <= this.base.x - this.lanes) {\n        if (my <= this.base.y - this.lanes) {\n          return 0;\n        } else {\n          return 1;\n        }\n      } else {\n        if (my <= this.base.y - this.lanes) {\n          return 3;\n        } else {\n          return 2;\n        }\n      }\n    }\n  }, {\n    key: \"getOut\",\n    value: function getOut(mx, my) {\n      if (mx <= this.base.x - this.lanes) {\n        if (my <= this.base.y - this.lanes) {\n          return 1;\n        } else {\n          return 2;\n        }\n      } else {\n        if (my <= this.base.y - this.lanes) {\n          return 0;\n        } else {\n          return 3;\n        }\n      }\n    }\n  }, {\n    key: \"getFrom\",\n    value: function getFrom(size, scale, side) {\n      //Need out location for line.\n      var xr, yr;\n\n      switch (side) {\n        case 0:\n          xr = (this.base.x - 0.5 * this.lanes + 1) * scale + size.x0;\n          yr = (this.base.y - 2 * this.lanes + 1.5) * scale + size.y0;\n          break;\n\n        case 1:\n          xr = (this.base.x - 2 * this.lanes + 1.5) * scale + size.x0;\n          yr = (this.base.y - 1.5 * this.lanes + 1) * scale + size.y0;\n          break;\n\n        case 2:\n          xr = (this.base.x - 1.5 * this.lanes + 1) * scale + size.x0;\n          yr = (this.base.y + 0.5) * scale + size.y0;\n          break;\n\n        case 3:\n          xr = (this.base.x + 0.5) * scale + size.x0;\n          yr = (this.base.y - 0.5 * this.lanes + 1) * scale + size.y0;\n          break;\n\n        default:\n          break;\n      }\n\n      return {\n        x: xr,\n        y: yr\n      };\n    }\n  }, {\n    key: \"getTo\",\n    value: function getTo(size, scale, side) {\n      //Use side to find \n      var xr, yr;\n\n      switch (side) {\n        case 0:\n          xr = (this.base.x - 1.5 * this.lanes + 1) * scale + size.x0;\n          yr = (this.base.y - 2 * this.lanes + 1.5) * scale + size.y0;\n          break;\n\n        case 1:\n          xr = (this.base.x - 2 * this.lanes + 1.5) * scale + size.x0;\n          yr = (this.base.y - 0.5 * this.lanes + 1) * scale + size.y0;\n          break;\n\n        case 2:\n          xr = (this.base.x - 0.5 * this.lanes + 1) * scale + size.x0;\n          yr = (this.base.y + 0.5) * scale + size.y0;\n          break;\n\n        case 3:\n          xr = (this.base.x + 0.5) * scale + size.x0;\n          yr = (this.base.y - 1.5 * this.lanes + 1) * scale + size.y0;\n          break;\n\n        default:\n          break;\n      }\n\n      return {\n        x: xr,\n        y: yr\n      };\n    }\n  }, {\n    key: \"getO\",\n    value: function getO(o) {\n      switch (o) {\n        case 0:\n          return {\n            x: -1,\n            y: -1,\n            xd: 1,\n            yd: 1,\n            lx: -1,\n            ly: 0,\n            px: 0,\n            py: -1\n          };\n          break;\n\n        case 1:\n          return {\n            x: -1,\n            y: 1,\n            xd: 1,\n            yd: 0,\n            lx: 0,\n            ly: 1,\n            px: -1,\n            py: 0\n          };\n          break;\n\n        case 2:\n          return {\n            x: 1,\n            y: 1,\n            xd: 0,\n            yd: 0,\n            lx: 1,\n            ly: 0,\n            px: 0,\n            py: 1\n          };\n          break;\n\n        case 3:\n          return {\n            x: 1,\n            y: -1,\n            xd: 0,\n            yd: 1,\n            lx: 0,\n            ly: -1,\n            px: 1,\n            py: 0\n          };\n          break;\n\n        default:\n      }\n    }\n  }, {\n    key: \"getDrawTransform\",\n    value: function getDrawTransform(side) {\n      var ret;\n\n      switch (side) {\n        case 0:\n          ret = {\n            dbasex: -1,\n            dbasey: -1,\n            lanex: 1,\n            laney: 0,\n            posx: 0,\n            posy: 1\n          };\n          break;\n\n        case 1:\n          ret = {\n            dbasex: -1,\n            dbasey: 0,\n            lanex: 0,\n            laney: -1,\n            posx: 1,\n            posy: 0\n          };\n          break;\n\n        case 2:\n          ret = {\n            dbasex: 0,\n            dbasey: 0,\n            lanex: -1,\n            laney: 0,\n            posx: 0,\n            posy: -1\n          };\n          break;\n\n        case 3:\n          ret = {\n            dbasex: 0,\n            dbasey: -1,\n            lanex: 0,\n            laney: 1,\n            posx: -1,\n            posy: 0\n          };\n          break;\n\n        default:\n      }\n\n      return ret;\n    }\n  }]);\n\n  return Intersection;\n}();\n\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Intersection);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/intersection.js?");

/***/ }),

/***/ "./src/js/traffic/road.js":
/*!********************************!*\
  !*** ./src/js/traffic/road.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar Road = /*#__PURE__*/function () {\n  //Roads track their 0lane, 0pos, lanes, length, and orientation\n  //TODO - make orientation not shitty.  Either enum like driver, or use explicit\n  //     - names in an input object that describe the orientation 'vectors' of the\n  //     - lane and position directions ex: {lanex: 0, laney: -1, posx: 1, posy: 0} \n  //     - orientation is a bunch of vectors that could probably be more simply\n  //     - expressed but w.e  it works right now. \n  function Road(rdata, orientation, length, lanes) {\n    _classCallCheck(this, Road);\n\n    this.orientation = orientation; // 0 iup (-y), 1 ileft(-x), 2 idown(+y), 3 iright(+x)\n\n    this.o = {\n      x: 0,\n      y: 0,\n      xd: 0,\n      yd: 0,\n      lx: -1,\n      ly: 0,\n      lanes: lanes\n    };\n    this.length = length;\n    this.lanes = lanes;\n    this.out = \"none\"; //Out is where cars are passed when they get to the end.\n\n    this.outside = 0;\n    this.outs = [];\n    this.outs[0] = \"none\";\n    this.colors = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(7);\n    this.start = {\n      xn: rdata.x,\n      yn: rdata.y,\n      x: 0,\n      y: 0\n    };\n    this.dim = {\n      xn0: rdata.x,\n      yn0: rdata.y,\n      xd0: 0,\n      yd0: 0,\n      dx: 0,\n      dy: 0\n    }; //Orientation and dimensions - makes drawing easier\n\n    this.o = this.getO(this.orientation);\n    console.log(this.orientation, this.o);\n    this.dim.xd0 = this.dim.xn0 + this.o.xd;\n    this.dim.yd0 = this.dim.yn0 + this.o.yd;\n    this.dim.dx = this.o.lx * this.lanes + this.o.px * this.length;\n    this.dim.dy = this.o.ly * this.lanes + this.o.py * this.length;\n    this.cars = [];\n    this.road = [];\n\n    for (var i = 0; i < lanes; i++) {\n      this.road[i] = [];\n\n      for (var j = 0; j < length; j++) {\n        this.road[i][j] = 0;\n      }\n    }\n  }\n\n  _createClass(Road, [{\n    key: \"draw\",\n    value: function draw(ctx, size) {\n      this.drawPavement(ctx, size);\n      this.drawCars(ctx, size);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      //Update Cars\n      //If an update pushes a car to the intersection, it asks the\n      //intersection if it can proceed, if so, pass and then remove\n      var forward = 0,\n          depass = 1,\n          pass = 1,\n          position = 0,\n          car = 0;\n\n      for (var c = 0; c < this.cars.length; c++) {\n        car = this.cars[c];\n\n        if (car.timer++ > car.speed) {\n          car.timer = 0; //If near end, do intersection shit\n\n          if (car.loc.pos === this.length - 1 && this.out !== \"none\") {\n            if (this.out.open(car.loc.lane, this.outside)) {\n              this.out.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_0__.default(car.id, {\n                lane: car.loc.lane,\n                pos: 0,\n                speed: car.speed\n              }, car.type), this.outside);\n              this.cars.splice(c, 1);\n              this.road[car.loc.lane][car.loc.pos] = 0;\n            }\n          } else {\n            switch (car.type) {\n              case 0:\n                //If you can depass, depass.\n                if (car.loc.lane > 0) {\n                  depass = this.road[car.loc.lane - 1][car.loc.pos + 1];\n\n                  if (depass === 0) {\n                    this.depass(car);\n                    return;\n                  }\n                } //If forward is clear go, else pass\n\n\n                forward = this.road[car.loc.lane + 0][car.loc.pos + 1];\n\n                if (forward === 0) {\n                  this.moveForward(car);\n                  return;\n                } else {\n                  if (car.loc.lane < this.lanes - 1) {\n                    pass = this.road[car.loc.lane + 1][car.loc.pos + 1];\n\n                    if (pass === 0) {\n                      //TODO - Pass function outta scope\n                      this.pass(car);\n                      return;\n                    }\n                  }\n                }\n\n                break;\n              // case Driver().CRAZY:\n              //     break;\n\n              default:\n                break;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"drawPavement\",\n    value: function drawPavement(ctx, size) {\n      //Grey rectangle under the road\n      ctx.fillStyle = \"lightgrey\";\n      var x0 = size.scale * this.dim.xd0 + size.x0;\n      var y0 = size.scale * this.dim.yd0 + size.y0;\n      ctx.beginPath();\n      ctx.rect(x0, y0, size.scale * this.dim.dx, size.scale * this.dim.dy);\n      ctx.fill(); //Outline the road\n\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(x0, y0);\n      ctx.lineTo(x0 + size.scale * this.o.px * this.length, y0 + size.scale * this.o.py * this.length);\n      ctx.stroke();\n      ctx.beginPath();\n      var xl = 0,\n          yl = 0;\n      xl = x0 + size.scale * this.o.lx * this.lanes;\n      yl = y0 + size.scale * this.o.ly * this.lanes;\n      ctx.moveTo(xl, yl);\n      ctx.lineTo(xl + size.scale * this.o.px * this.length, yl + size.scale * this.o.py * this.length);\n      ctx.stroke(); //Draw lane lines\n\n      if (this.lanes > 1) {\n        ctx.strokeStyle = \"darkgrey\";\n        ctx.lineWidth = 3;\n        var xp = 0,\n            yp = 0;\n\n        for (var l = 1; l < this.lanes; l++) {\n          xl = x0 + size.scale * this.o.lx * l;\n          yl = y0 + size.scale * this.o.ly * l;\n\n          for (var p = 0; p < this.length; p += 2) {\n            xp = xl + size.scale * this.o.px * p;\n            yp = yl + size.scale * this.o.py * p;\n            ctx.beginPath();\n            ctx.moveTo(xp, yp);\n            ctx.lineTo(xp + size.scale * this.o.px, yp + size.scale * this.o.py);\n            ctx.stroke();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"drawCars\",\n    value: function drawCars(ctx, size) {\n      var cloc = {\n        x: 0,\n        y: 0\n      };\n\n      for (var c = 0; c < this.cars.length; c++) {\n        var car = this.cars[c];\n        cloc.x = size.scale * (this.dim.xd0 + this.o.lx * car.loc.lane + this.o.px * car.loc.pos) + size.x0;\n        cloc.y = size.scale * (this.dim.yd0 + this.o.ly * car.loc.lane + this.o.py * car.loc.pos) + size.y0;\n        ctx.beginPath();\n        ctx.fillStyle = this.colors.get(car.id);\n        ctx.fillRect(cloc.x + 2 * this.o.x, cloc.y + 2 * this.o.y, size.scale * this.o.x - 4 * this.o.x, size.scale * this.o.y - 4 * this.o.y);\n      }\n    }\n  }, {\n    key: \"addCar\",\n    value: function addCar(c) {\n      this.cars.push(c);\n      this.road[c.loc.lane][c.loc.pos] = c;\n    }\n  }, {\n    key: \"setOutput\",\n    value: function setOutput(r, s) {\n      this.out = r;\n      this.outs[0] = r;\n      this.outside = s;\n    }\n  }, {\n    key: \"depass\",\n    value: function depass(c) {\n      this.road[c.loc.lane][c.loc.pos] = 0;\n      c.loc.lane--;\n      c.loc.pos++;\n      this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n  }, {\n    key: \"moveForward\",\n    value: function moveForward(c) {\n      this.road[c.loc.lane][c.loc.pos] = 0;\n      c.loc.pos++;\n      this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n  }, {\n    key: \"pass\",\n    value: function pass(c) {\n      this.road[c.loc.lane][c.loc.pos] = 0;\n      c.loc.lane++;\n      c.loc.pos++;\n      this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n  }, {\n    key: \"open\",\n    value: function open(lane, s) {\n      return this.road[lane][0] === 0;\n    }\n  }, {\n    key: \"add\",\n    value: function add(c) {\n      this.cars.push(c);\n      var n = this.cars.length; //this.cars[n - 1].loc = {lane: 0, pos: 0};\n\n      this.road[c.loc.lane][0] = c;\n    }\n  }, {\n    key: \"getFrom\",\n    value: function getFrom(size, scale, side) {\n      var xout, yout;\n      xout = (this.dim.xd0 + (this.length - 0.5) * this.o.px + this.lanes / 2 * this.o.lx) * scale + size.x0;\n      yout = (this.dim.yd0 + (this.length - 0.5) * this.o.py + this.lanes / 2 * this.o.ly) * scale + size.y0;\n      return {\n        x: xout,\n        y: yout\n      };\n    }\n  }, {\n    key: \"getTo\",\n    value: function getTo(size, scale, side) {\n      return {\n        x: (this.dim.xd0 + 0.5 * this.o.lx * this.lanes + this.o.px * 0.5) * scale + size.x0,\n        y: (this.dim.yd0 + 0.5 * this.o.ly * this.lanes + this.o.py * 0.5) * scale + size.y0\n      };\n    }\n  }, {\n    key: \"getO\",\n    value: function getO(o) {\n      switch (o) {\n        case 0:\n          return {\n            x: -1,\n            y: -1,\n            xd: 1,\n            yd: 1,\n            lx: -1,\n            ly: 0,\n            px: 0,\n            py: -1\n          };\n          break;\n\n        case 1:\n          return {\n            x: -1,\n            y: 1,\n            xd: 1,\n            yd: 0,\n            lx: 0,\n            ly: 1,\n            px: -1,\n            py: 0\n          };\n          break;\n\n        case 2:\n          return {\n            x: 1,\n            y: 1,\n            xd: 0,\n            yd: 0,\n            lx: 1,\n            ly: 0,\n            px: 0,\n            py: 1\n          };\n          break;\n\n        case 3:\n          return {\n            x: 1,\n            y: -1,\n            xd: 0,\n            yd: 1,\n            lx: 0,\n            ly: -1,\n            px: 1,\n            py: 0\n          };\n          break;\n\n        default:\n      }\n    }\n  }]);\n\n  return Road;\n}();\n\n;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Road);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/road.js?");

/***/ }),

/***/ "./src/js/traffic/simulation.js":
/*!**************************************!*\
  !*** ./src/js/traffic/simulation.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\n/* harmony import */ var _inputhandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputhandler.js */ \"./src/js/traffic/inputhandler.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/* TSimulation class that will run all the things\n * \n * ctx, world, units, logic, draw, loop\n * \n * @param {canvas element} canvas\n * @returns {TSimulation}\n */\n\nvar Simulation = /*#__PURE__*/function () {\n  function Simulation(canvas) {\n    _classCallCheck(this, Simulation);\n\n    this.canvas = canvas;\n    this.scale = 12;\n    this.size = this.getSize();\n    this.ctx = this.canvas.getContext('2d');\n    this.roads = [];\n    this.intersections = [];\n    this.input = new _inputhandler_js__WEBPACK_IMPORTED_MODULE_2__.default(this);\n    this.color = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(10);\n  }\n\n  _createClass(Simulation, [{\n    key: \"run\",\n    value: function run() {\n      var self = this;\n\n      var tick = function tick() {\n        self.update();\n        self.draw();\n        setTimeout(function () {\n          requestAnimationFrame(tick);\n        }, 1000 / self.fps);\n      };\n\n      tick(); //Start the show\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var i; //Update each road, update each intersection\n\n      for (i = 0; i < this.roads.length; i++) {\n        this.roads[i].update();\n      }\n\n      for (i = 0; i < this.intersections.length; i++) {\n        this.intersections[i].update();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.drawGrid();\n      var i; //Draw each road, intersection\n\n      for (i = 0; i < this.roads.length; i++) {\n        this.roads[i].draw(this.ctx, this.size);\n      }\n\n      for (i = 0; i < this.intersections.length; i++) {\n        this.intersections[i].draw(this.ctx, this.size);\n      }\n\n      this.input.draw();\n    }\n  }, {\n    key: \"drawGrid\",\n    value: function drawGrid() {\n      var crosssize = this.scale * 0.25;\n      var blanksize = this.scale - crosssize;\n      this.ctx.strokeStyle = \"black\";\n      this.ctx.lineWidth = 1;\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5);\n      this.ctx.lineTo(crosssize / 2 + this.size.x0 + 0.5, this.size.y0 + 0.5);\n      this.ctx.stroke();\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5);\n      this.ctx.lineTo(this.size.x0 + 0.5, crosssize / 2 + this.size.y0 + 0.5);\n      this.ctx.stroke();\n\n      for (var i = 0; i < this.size.x + 1; i++) {\n        this.ctx.setLineDash([]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.size.x0 + 0.5 + this.scale * i, this.size.y0 + 0.5);\n        this.ctx.lineTo(this.size.x0 + 0.5 + this.scale * i, this.size.y0 + 0.5 + crosssize / 2);\n        this.ctx.stroke();\n        this.ctx.setLineDash([crosssize, blanksize]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(i * this.scale + this.size.x0 + 0.5, this.size.y0 + 0.5 + blanksize + crosssize / 2);\n        this.ctx.lineTo(i * this.scale + this.size.x0 + 0.5, this.size.y0 + this.size.h + 0.5);\n        this.ctx.stroke();\n      }\n\n      for (var j = 0; j < this.size.y + 1; j++) {\n        this.ctx.setLineDash([]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5 + this.scale * j);\n        this.ctx.lineTo(this.size.x0 + 0.5 + crosssize / 2, this.size.y0 + 0.5 + this.scale * j);\n        this.ctx.stroke();\n        this.ctx.setLineDash([crosssize, blanksize]);\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.size.x0 + 0.5 + blanksize + crosssize / 2, j * this.scale + this.size.y0 + 0.5);\n        this.ctx.lineTo(this.size.x0 + this.size.w + 0.5, j * this.scale + this.size.y0 + 0.5);\n        this.ctx.stroke();\n      }\n\n      this.ctx.setLineDash([]);\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      //Return 0 point of drawing grid, width of grid in pixels/cells\n      var rect = this.canvas.getBoundingClientRect(); // const mx = event.clientX - rect.left\n      // const my = event.clientY - rect.top\n\n      var width = rect.width;\n      var height = rect.height; // var width  = this.canvas.width;\n      // var height = this.canvas.height;\n\n      var xn = Math.floor((width - this.scale) / this.scale);\n      var yn = Math.floor((height - this.scale) / this.scale);\n      return {\n        x: xn,\n        y: yn,\n        w: xn * this.scale,\n        h: yn * this.scale,\n        x0: (width - xn * this.scale) / 2,\n        y0: (height - yn * this.scale) / 2,\n        scale: this.scale\n      };\n    }\n  }, {\n    key: \"addRoad\",\n    value: function addRoad(r) {\n      this.roads.push(r);\n    }\n  }, {\n    key: \"addCar\",\n    value: function addCar(r, c) {\n      var road = this.roads[r];\n      road.addCar(c);\n    }\n  }, {\n    key: \"addIntersection\",\n    value: function addIntersection(i) {\n      this.intersections.push(i);\n    }\n  }, {\n    key: \"connectRoad\",\n    value: function connectRoad(from, to) {\n      this.roads[from].setOutput(this.roads[to]);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(from, to) {\n      //Make it agnostic.  Intersections will be passed as int.side to differentiat sides\n      from.out = to;\n    }\n  }, {\n    key: \"connectRtoI\",\n    value: function connectRtoI(rfrom, intto, side) {\n      this.roads[rfrom].setOutput(this.intersections[intto], side);\n    }\n  }, {\n    key: \"connectItoR\",\n    value: function connectItoR(intfrom, rto, side) {\n      this.intersections[intfrom].setOutput(this.roads[rto], side);\n    }\n  }, {\n    key: \"printStats\",\n    value: function printStats() {\n      var str, r, inter;\n      str = \"\"; //Roads\n\n      for (var i = 0; i < this.roads.length; i++) {\n        r = this.roads[i];\n        str += \" sim.addRoad( new Road({\";\n        str += \"x: \" + r.start.xn + \", y: \" + r.start.yn + \"},\";\n        str += r.orientation + \", \" + r.length + \", \" + r.lanes + \"));\\n\";\n      } //Intersections\n\n\n      for (var i = 0; i < this.intersections.length; i++) {\n        inter = this.intersections[i];\n        str += \" sim.addIntersection( new Intersection({\";\n        str += \"x: \" + inter.base.x + \", y: \" + inter.base.y + \"},\";\n        str += inter.lanes + \", 1));\\n\";\n      } //Connections - Roads\n\n\n      for (var i = 0; i < this.roads.length; i++) {\n        r = this.roads[i];\n        str += \" sim.addRoad( new Road({\";\n        str += \"x: \" + r.start.xn + \", y: \" + r.start.yn + \"},\";\n        str += r.orientation + \", \" + r.length + \", \" + r.lanes + \"));\\n\";\n      }\n\n      console.log(str);\n    }\n  }]);\n\n  return Simulation;\n}();\n\n;\n\nfunction Driver() {\n  return {\n    NORMAL: 0,\n    SLOW: 1,\n    CRAZY: 2\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Simulation);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/simulation.js?");

/***/ }),

/***/ "./src/js/traffic/traffic.js":
/*!***********************************!*\
  !*** ./src/js/traffic/traffic.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simulation.js */ \"./src/js/traffic/simulation.js\");\n/* harmony import */ var _road_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./road.js */ \"./src/js/traffic/road.js\");\n/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intersection.js */ \"./src/js/traffic/intersection.js\");\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n// import '../style.css';\n\n\n\n // var canvas = $(\"#trafficcanvas\");\n\nvar canvas = document.getElementById('trafficcanvas');\nvar sim = new _simulation_js__WEBPACK_IMPORTED_MODULE_0__.default(canvas);\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 8,\n  y: 20\n}, 0, 15, 2)); //0 - Up   (leftish)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 38,\n  y: 20\n}, 0, 15, 2)); //1 - Up   (rightish)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 34,\n  y: 21\n}, 1, 26, 2)); //2 - Left (lower)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 34,\n  y: 2\n}, 1, 26, 2)); //3 - Left (upper)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 5,\n  y: 6\n}, 2, 15, 2)); //4 - Down  (leftsh)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 35,\n  y: 6\n}, 2, 15, 2)); //5 - Down  (rightish)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 9,\n  y: 24\n}, 3, 26, 2)); //6 - Right (lower)\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({\n  x: 9,\n  y: 5\n}, 3, 26, 2)); //7 - Rght (uppwr)\n\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({\n  x: 8,\n  y: 5\n}, 2, 1)); //0 (up left)\n\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({\n  x: 38,\n  y: 5\n}, 2, 1)); //1 (up right)\n\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({\n  x: 38,\n  y: 24\n}, 2, 1)); //2 (down right)\n\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({\n  x: 8,\n  y: 24\n}, 2, 1)); //3 (down left)\n\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(0, {\n  lane: 0,\n  pos: 1,\n  speed: 30\n}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(1, {\n  lane: 0,\n  pos: 5,\n  speed: 50\n}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(2, {\n  lane: 0,\n  pos: 10,\n  speed: 70\n}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(3, {\n  lane: 1,\n  pos: 1,\n  speed: 50\n}, 0));\nsim.addCar(4, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(4, {\n  lane: 0,\n  pos: 1,\n  speed: 30\n}, 0));\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(8, {\n  lane: 0,\n  pos: 1,\n  speed: 30\n}, 0));\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(9, {\n  lane: 0,\n  pos: 5,\n  speed: 50\n}, 0));\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(10, {\n  lane: 1,\n  pos: 1,\n  speed: 50\n}, 0));\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(11, {\n  lane: 0,\n  pos: 1,\n  speed: 30\n}, 0));\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(12, {\n  lane: 0,\n  pos: 5,\n  speed: 50\n}, 0));\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(13, {\n  lane: 1,\n  pos: 1,\n  speed: 50\n}, 0));\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(14, {\n  lane: 0,\n  pos: 1,\n  speed: 30\n}, 0));\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(15, {\n  lane: 0,\n  pos: 5,\n  speed: 50\n}, 0));\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(16, {\n  lane: 1,\n  pos: 1,\n  speed: 50\n}, 0)); //Upperleft\n\nsim.connectRtoI(0, 0, 2);\nsim.connectRtoI(3, 0, 3);\nsim.connectItoR(0, 4, 2);\nsim.connectItoR(0, 7, 3); //Upperright\n\nsim.connectRtoI(1, 1, 2);\nsim.connectRtoI(7, 1, 1);\nsim.connectItoR(1, 3, 1);\nsim.connectItoR(1, 5, 2); //Lowerright\n\nsim.connectRtoI(6, 2, 1);\nsim.connectRtoI(5, 2, 0);\nsim.connectItoR(2, 1, 0);\nsim.connectItoR(2, 2, 1); //Lowerleft\n\nsim.connectRtoI(2, 3, 3);\nsim.connectRtoI(4, 3, 0);\nsim.connectItoR(3, 6, 3);\nsim.connectItoR(3, 0, 0);\nsim.run();\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/traffic.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/traffic/traffic.js");
/******/ 	
/******/ })()
;