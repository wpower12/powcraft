/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/traffic/car.js":
/*!*******************************!*\
  !*** ./src/js/traffic/car.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Car {\n    constructor(id, cardata, type){\n\t\tthis.id = id;\n\t\tthis.loc = {lane: cardata.lane, pos: cardata.pos};\n\t\tthis.type = type;\n\t\tthis.speed = cardata.speed;\n\t\tthis.timer = 0;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Car);\n\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/car.js?");

/***/ }),

/***/ "./src/js/traffic/colorpicker.js":
/*!***************************************!*\
  !*** ./src/js/traffic/colorpicker.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass ColorPicker {\n    constructor(n){\n    \tthis.s = 90;\n\t    this.l = 40;\n\t    this.delta = 360 / n;\n    }\n};\n$.extend(ColorPicker.prototype, {\n    //Returns the css color string used by canvas\n    get: function (c) {\n        var ret = 'hsl(' + c * this.delta + ',' + this.s + '%,' + this.l + '%' + ')';\n        return ret;\n    }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorPicker);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/colorpicker.js?");

/***/ }),

/***/ "./src/js/traffic/inputhandler.js":
/*!****************************************!*\
  !*** ./src/js/traffic/inputhandler.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _road_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./road.js */ \"./src/js/traffic/road.js\");\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intersection.js */ \"./src/js/traffic/intersection.js\");\n\n\n\n\nvar DRIVERS = [\"Normal\", \"Slow\", \"Crazy\"];\n\nclass InputHandler {\n\tconstructor(sim){\n\t    this.sim = sim;\n\t    \n        this.btn_car   = document.getElementById('btn-car');\n        this.btn_road  = document.getElementById('btn-road');\n        this.btn_inter = document.getElementById('btn-inter');\n        this.btn_sim   = document.getElementById('btn-sim');\n\n        this.btn_connect = document.getElementById('btn-connect');\n        this.btn_delete  = document.getElementById('btn-delete');\n\n        this.el_ctrl_car   = document.getElementById('car-toolbar');\n        this.el_ctrl_road  = document.getElementById('road-toolbar');\n        this.el_ctrl_inter = document.getElementById('inter-toolbar');\n        this.el_ctrl_sim   = document.getElementById('sim-toolbar');\n\n        this.$speed     = document.getElementById('car-in-speed');\n        this.$color     = document.getElementById('car-in-color');\n        this.$roadlanes = document.getElementById('road-in-lanes');\n        this.$roador    = document.getElementById('road-in-orient');    \n        this.$length    = document.getElementById('road-in-length');\n        this.$intlanes  = document.getElementById('inter-in-lanes');\n\t       \n\t    //Drawing/Adding fields\n\t    this.selected = 0; //0 - Car, 1 - Road, 2 - Intersection, 3 - Connection, 4 - Delete\n\t    this.mousecell = {x: 0, y: 0};\n\t    this.mousecell = {x: 0, y: 0};\n\t    this.timer = 0;\n\t    this.drawing = true;\n\n        // Not sure wht i did it this way. \n        this.r = new _road_js__WEBPACK_IMPORTED_MODULE_0__.default({x: 0, y: 0}, 0, 0, 0);\n\n\t    this.roadfits = true;\n\t    this.connclicked = false;\n\t    this.openroad = \"\";\n\t    this.openroadside = 0;\n\n\t    this.updateValues();\n        this.attachButtonListeners();\n\t    this.attachInputs();\n\t}\n\n    attachButtonListeners(){\n        this.btn_car.addEventListener('click', function(e){\n            this.el_ctrl_road.classList.add(\"hidden\");\n            this.el_ctrl_inter.classList.add(\"hidden\");\n            this.el_ctrl_sim.classList.add(\"hidden\");\n            this.el_ctrl_car.classList.remove(\"hidden\");\n            this.selected = 0; \n        }.bind(this));\n\n        this.btn_road.addEventListener('click', function(e){\n            this.el_ctrl_car.classList.add(\"hidden\");\n            this.el_ctrl_inter.classList.add(\"hidden\");\n            this.el_ctrl_sim.classList.add(\"hidden\");\n            this.el_ctrl_road.classList.remove(\"hidden\");\n            this.selected = 1;\n        }.bind(this));\n\n        this.btn_inter.addEventListener('click', function(e){\n            this.el_ctrl_car.classList.add(\"hidden\");\n            this.el_ctrl_road.classList.add(\"hidden\");\n            this.el_ctrl_sim.classList.add(\"hidden\");\n            this.el_ctrl_inter.classList.remove(\"hidden\");\n            this.selected = 2;\n        }.bind(this));\n\n        this.btn_sim.addEventListener('click', function(e){\n            this.el_ctrl_road.classList.add(\"hidden\");\n            this.el_ctrl_inter.classList.add(\"hidden\");\n            this.el_ctrl_car.classList.add(\"hidden\");\n            this.el_ctrl_sim.classList.remove(\"hidden\");\n            this.selected = 3; // start on connect.\n        }.bind(this));\n\n        this.btn_connect.addEventListener('click', function(e){\n            this.selected = 3;\n        }.bind(this));\n\n        this.btn_delete.addEventListener('click', function(e){\n            this.selected = 4;\n        }.bind(this));\n    }\n\n    attachInputs () {\n        //On mouse move to update data for drawing\n        this.sim.canvas.addEventListener('mousemove', function (e) {\n            this.mousepos = this.calculateMousePos(e);\n            this.mousecell = this.calculateMouseCell();\n            this.checkInsertionFit();   //This updates fields used by the click callbacks\n            //Reset Drawing timer\n            this.timer = 0;\n            this.drawing = true;\n        }.bind(this));\n\n        //On mouse click to add things\n        this.sim.canvas.addEventListener('click', function (e) {\n        \tthis.updateValues();\n            switch (this.selected) {\n                case 0: //Car\n                    this.carClickCallback();\n                    break;\n                case 1: //Road\n                    this.roadClickCallback();\n                    break;\n                case 2: //Intersection\n                    this.interClickCallback();\n                    break;\n                case 3: //Connection\n                    this.connClickCallback();\n                    break;\n                case 4: //Delete\n                    this.deleteClickCallback();\n                default:\n            }\n        }.bind(this));\n    }\n\n    updateValues(){\n        this._speed     = this.$speed.value;\n        this._color     = this.$color.value;\n        this._roadlanes = this.$roadlanes.value;\n        this._length    = this.$length.value;\n        this._intlanes  = this.$intlanes.value;\n        this._roador    = this.$roador.value;\n    }\n\n    draw () {\n        this.updateValues();\n        var ctx = this.sim.ctx;\n        if (this.mousecell.y >= 0\n                && this.mousecell.x >= 0\n                && this.mousecell.y < this.sim.size.y\n                && this.mousecell.x < this.sim.size.x) {\n            switch (this.selected) {\n                case 0: //Car\n                    this.drawCar(ctx);\n                    break;\n                case 1: //Road\n                    this.drawRoad(ctx);\n                    break;\n                case 2: //Intersections\n                    this.drawInt(ctx);\n                    break;\n                case 3: //Connections\n                    this.drawConn(ctx);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    drawCar (ctx) {\n        if (++this.timer > 20) {\n            this.drawing = !this.drawing;\n            this.timer = 0;\n        }\n        if (this.drawing) {\n            ctx.beginPath();\n            ctx.fillStyle = \"grey\";\n            ctx.fillRect(this.mousecell.x * this.sim.scale + this.sim.size.x0 + 2,\n                    this.mousecell.y * this.sim.scale + this.sim.size.y0 + 2,\n                    this.sim.scale - 3, this.sim.scale - 3);\n        }\n    }\n\n    drawRoad (ctx) {\n        if (this.drawing) {\n            //Draw the rectangle\n            var rx, ry, dx, dy, o, or;\n            o = this._roador;\n            or = this.r.getO(o * 1);\n            rx = (this.mousecell.x + or.xd) * this.sim.scale + this.sim.size.x0;\n            ry = (this.mousecell.y + or.yd) * this.sim.scale + this.sim.size.y0;\n            dx = (this._roadlanes * or.lx + this._length * or.px) * this.sim.scale - 1 * or.lx - 1 * or.px;\n            dy = (this._roadlanes * or.ly + this._length * or.py) * this.sim.scale - 1 * or.ly - 1 * or.py;\n            ctx.strokeStyle = \"grey\";\n            ctx.beginPath();\n            ctx.setLineDash([5]);\n            ctx.lineWidth = 3;\n            ctx.rect(rx, ry, dx, dy);\n            ctx.stroke();\n            ctx.setLineDash([0]);\n\n            //Draw direction arrow\n            var mx, my, ax, ay, tx, ty;\n            mx = rx + 0.5 * this._roadlanes * this.sim.scale * or.lx;\n            my = ry + 0.5 * this._roadlanes * this.sim.scale * or.ly;\n            ax = mx + this._length * this.sim.scale * or.px;\n            ay = my + this._length * this.sim.scale * or.py;\n            ctx.strokeStyle = \"grey\";\n            ctx.beginPath();\n            ctx.moveTo(mx, my);\n            ctx.lineTo(ax, ay);\n            ctx.stroke();\n\n            ctx.beginPath();\n            tx = ax - this.sim.scale * or.px - 0.5 * this.sim.scale * or.lx;\n            ty = ay - this.sim.scale * or.py - 0.5 * this.sim.scale * or.ly;\n            ctx.moveTo(ax, ay);\n            ctx.lineTo(tx, ty);\n            ctx.moveTo(ax, ay);\n            tx = ax - this.sim.scale * or.px + 0.5 * this.sim.scale * or.lx;\n            ty = ay - this.sim.scale * or.py + 0.5 * this.sim.scale * or.ly;\n            ctx.lineTo(tx, ty);\n            ctx.stroke();\n        }\n    }\n\n    drawInt (ctx) {\n        //Draw an outline of the square representing the intersection.\n        var rx, ry, d;\n        rx = (this.mousecell.x + 1) * this.sim.scale + this.sim.size.x0;\n        ry = (this.mousecell.y + 1) * this.sim.scale + this.sim.size.y0;\n        d = -1 * this._intlanes * this.sim.scale;\n        ctx.strokeStyle = \"grey\";\n        ctx.beginPath();\n        ctx.setLineDash([5]);\n        ctx.lineWidth = 3;\n        ctx.rect(rx, ry, d * 2, d * 2);\n        ctx.stroke();\n        ctx.setLineDash([0]);\n    }\n\n    drawConn (ctx) {\n        //Road Output Connections\n        var road;\n        for (var i = 0; i < this.sim.roads.length; i++) {\n            road = this.sim.roads[i];\n            if (!(road.out === \"none\")) {\n                this.drawConnLineRoad(ctx, road);\n            }\n            this.drawDirectionArrow(ctx, road);\n        }\n        //Intersection Output Connections\n        var int, outx0, outy0, inx0, iny0, dx, dy;\n        for (var i = 0; i < this.sim.intersections.length; i++) {\n            this.drawConnLineInt(ctx, this.sim.intersections[i]);\n        }\n        //If an open output is clicked, draw a line from output to cursor\n        if (this.connclicked === true) {\n            this.drawMouseLine(ctx);\n        }\n    }\n\n    drawConnLineRoad (ctx, road) {\n        var from, to;\n        from = {\n            x: (road.dim.xd0 + road.o.px * (road.length - 0.5) + 0.5 * road.o.lx * road.lanes) * this.sim.scale + this.sim.size.x0,\n            y: (road.dim.yd0 + road.o.py * (road.length - 0.5) + 0.5 * road.o.ly * road.lanes) * this.sim.scale + this.sim.size.y0\n        };\n        to = road.out.getTo(this.sim.size, this.sim.scale, road.outside);\n        ctx.beginPath();\n        ctx.strokeStyle = \"#B33D3D\";\n        ctx.lineWidth = 2;\n        ctx.moveTo(from.x, from.y);\n        ctx.lineTo(to.x, to.y);\n        ctx.stroke();\n    }\n\n    drawConnLineInt (ctx, int) {\n        for (var side = 0; side < 4; side++) {\n            if (!(int.outs[side] === \"none\")) {\n                this.drawOutLineInt(ctx, int, side);\n            } else {\n                this.drawOutputsInt(ctx, int, side);\n            }\n        }\n    }\n\n    drawDirectionArrow (ctx, road) {\n        //Draw direction arrow\n        var mx, my, ax, ay, tx, ty;\n\n        ax = road.dim.xd0 + (0.5 * road.length * road.o.px) + (0.5 * road.o.lx * road.lanes);\n        ay = road.dim.yd0 + (0.5 * road.length * road.o.py) + (0.5 * road.o.ly * road.lanes);\n\n        ctx.strokeStyle = \"#B33D3D\";\n\n        ctx.beginPath();\n        tx = (ax - 0.5 * road.o.lx - 0.5 * road.o.px) * this.sim.scale;\n        ty = (ay - 0.5 * road.o.ly - 0.5 * road.o.py) * this.sim.scale;\n        ctx.moveTo(ax * this.sim.scale + this.sim.size.x0, ay * this.sim.scale + this.sim.size.y0);\n        ctx.lineTo(tx + this.sim.size.x0, ty + this.sim.size.y0);\n        ctx.moveTo(ax * this.sim.scale + this.sim.size.x0, ay * this.sim.scale + this.sim.size.y0);\n        tx = (ax + 0.5 * road.o.lx - 0.5 * road.o.px) * this.sim.scale;\n        ty = (ay + 0.5 * road.o.ly - 0.5 * road.o.py) * this.sim.scale;\n        ctx.lineTo(tx + this.sim.size.x0, ty + this.sim.size.y0);\n        ctx.stroke();\n    }\n\n    drawMouseLine (ctx, road) {\n        var from = this.openroad.getFrom(this.sim.size, this.sim.scale, this.openroadside);\n        ctx.beginPath();\n        ctx.strokeStyle = \"#B33D3D\";\n        ctx.moveTo(from.x, from.y);\n        ctx.lineTo(this.mousepos.x, this.mousepos.y);\n        ctx.stroke();\n    }\n\n    drawOutputsInt (ctx, int, side) {\n        //Draw Rectangles\n        var outx0, outy0, inx0, iny0, dx, dy;\n        switch (side) {\n            case 0:\n                outx0 = int.base.x;\n                outy0 = int.base.y - 2 * int.lanes + 1;\n                inx0 = int.base.x - int.lanes + 1;\n                iny0 = int.base.y - 2 * int.lanes + 1;\n                dx = -1 * (int.lanes - 1);\n                dy = 1;\n                break;\n            case 1:\n                outx0 = int.base.x - 2 * int.lanes + 1;\n                outy0 = int.base.y - 2 * int.lanes + 2;\n                inx0 = outx0;\n                iny0 = int.base.y - int.lanes + 1;\n                ;\n                dx = 1;\n                dy = int.lanes - 1;\n                break;\n            case 2:\n                outx0 = int.base.x - 2 * int.lanes + 2;\n                outy0 = int.base.y;\n                inx0 = int.base.x - int.lanes + 1;\n                iny0 = outy0;\n                dx = int.lanes - 1;\n                dy = 1;\n                break;\n            case 3:\n                outx0 = int.base.x;\n                outy0 = int.base.y;\n                inx0 = outx0;\n                iny0 = int.base.y - int.lanes + 1;\n                dx = 1;\n                dy = -1 * (int.lanes - 1);\n                break;\n        }\n        ctx.beginPath();\n        ctx.strokeStyle = \"#B33D3D\";\n        ctx.rect(outx0 * this.sim.scale + this.sim.size.x0,\n                outy0 * this.sim.scale + this.sim.size.y0,\n                dx * this.sim.scale,\n                dy * this.sim.scale);\n        ctx.rect(inx0 * this.sim.scale + this.sim.size.x0,\n                iny0 * this.sim.scale + this.sim.size.y0,\n                dx * this.sim.scale,\n                dy * this.sim.scale);\n        ctx.stroke();\n    }\n\n    drawOutLineInt (ctx, int, side) {\n        var from, to;\n        from = int.getFrom(this.sim.size, this.sim.scale, side);\n        to = int.outs[side].getTo(this.sim.size, this.sim.scale, side);\n        ctx.beginPath();\n        ctx.strokeStyle = \"#B33D3D\";\n        ctx.moveTo(from.x, from.y);\n        ctx.lineTo(to.x, to.y);\n        ctx.stroke();\n    }\n\n    carClickCallback () {\n        var mx, my;\n        mx = this.mousecell.x;\n        my = this.mousecell.y;\n        if (mx >= 0 && my >= 0 && mx < this.sim.size.x && my < this.sim.size.y) {\n            //Find which road or intersection the car goes in\n            for (var i = 0; i < this.sim.roads.length; i++) {\n                if (this.insideRoad(mx, my, this.sim.roads[i])) {\n                    var target = this.sim.roads[i];\n                    var pos = this.getPos(mx, my, target);\n\n                    //Check that it doesnt hit another car.\n                    if (target.road[pos.l][pos.p] === 0) {\n                        target.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_1__.default(this._color, {lane: pos.l, pos: pos.p, speed: this._speed}, Driver().NORMAL));\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    roadClickCallback () {\n        var mx, my;\n        mx = this.mousecell.x;\n        my = this.mousecell.y;\n        if (this.roadfits) {\n            // console.log(this._roador)\n            this.sim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_0__.default({x: mx, y: my}, 1*this._roador, this._length, this._roadlanes));\n        }\n    }\n\n    interClickCallback () {\n        var mx, my;\n        mx = this.mousecell.x;\n        my = this.mousecell.y;\n        if (this.roadfits) {\n            this.sim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({x: mx, y: my}, this._intlanes, 0));\n        }\n    }\n\n    connClickCallback () {\n        var mx, my;\n        mx = this.mousecell.x;\n        my = this.mousecell.y;\n        if (this.connclicked) {\n            //Check if click is on a road\n            for (var i = 0; i < this.sim.roads.length; i++) {\n                if (this.insideRoad(mx, my, this.sim.roads[i])) {\n                    var target = this.sim.roads[i];\n                    this.openroad.setOutput(target, this.openroadside);\n                    break;\n                }\n            }\n            //Check if click is on an intersection\n            for (var i = 0; i < this.sim.intersections.length; i++) {\n                if (this.insideInt(mx, my, this.sim.intersections[i])) {\n                    var target = this.sim.intersections[i];\n                    this.openroad.setOutput(target, target.getSide(mx, my));\n                    break;\n                }\n            }\n            this.connclicked = false;\n        } else {\n            //Check if click is on a connection\n            for (var i = 0; i < this.sim.roads.length; i++) {\n                if (this.insideRoad(mx, my, this.sim.roads[i])) {\n                    this.sim.roads[i].out = \"none\";\n                    this.openroad = this.sim.roads[i];\n                    this.openroadside = 0; //Hack for road/intersection 'polymorphism'\n                    break;\n                }\n            }\n            //Check if click is on an intersection\n            var inter;\n            for (var i = 0; i < this.sim.intersections.length; i++) {\n                inter = this.sim.intersections[i];\n                if (this.insideInt(mx, my, inter)) {\n                    inter.outs[inter.getOut(mx, my)] = \"none\";\n                    this.openroad = inter;\n                    this.openroadside = inter.getOut(mx, my);\n                    break;\n                }\n            }\n            this.connclicked = true;\n        }\n    }\n\n    deleteClickCallback () {\n        var mx, my;\n        mx = this.mousecell.x;\n        my = this.mousecell.y;\n        for (var i = 0; i < this.sim.roads.length; i++) {\n            if (this.insideRoad(mx, my, this.sim.roads[i])) {\n                this.sim.roads.splice( i, 1 );\n                break;\n            }\n        }\n        //Check if click is on an intersection\n        for (var i = 0; i < this.sim.intersections.length; i++) {\n            if (this.insideInt(mx, my, this.sim.intersections[i])) {\n                this.sim.intersections.splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    calculateMousePos (event){\n    \tconst rect = this.sim.canvas.getBoundingClientRect()\n\t    const mx = event.clientX - rect.left\n\t    const my = event.clientY - rect.top\n\t    return {x: mx, y: my};\n    }\n\n    calculateMouseCell () {\n        var mx = this.mousepos.x;\n        var my = this.mousepos.y;\n        mx = mx - this.sim.size.x0-(this.sim.scale/4);\n        my = my - this.sim.size.y0-(this.sim.scale/4);\n        mx = Math.floor(mx / this.sim.scale);\n        my = Math.floor(my / this.sim.scale);\n        return {x: mx, y: my};\n    }\n\n    checkInsertionFit () {\n        var rx0, ry0, rxn, ryn, or, o, bottom, top, left, right;\n        rx0 = this.mousecell.x;\n        ry0 = this.mousecell.y;\n        switch (this.selected) {\n            case 1:\n                o = this._roador;\n                or = this.r.getO(o * 1);\n                rxn = rx0 + ((this._roadlanes - 1) * or.lx + (this._length - 1) * or.px);\n                ryn = ry0 + ((this._roadlanes - 1) * or.ly + (this._length - 1) * or.py);\n\n                top = Math.max(ry0, ryn);\n                bottom = Math.min(ry0, ryn);\n                left = Math.min(rx0, rxn);\n                right = Math.max(rx0, rxn);\n                break;\n            case 2:\n                rxn = rx0 - this._intlanes * 2 + 1;\n                ryn = ry0 - this._intlanes * 2 + 1;\n\n                top = Math.max(ry0, ryn);\n                bottom = Math.min(ry0, ryn);\n                left = Math.min(rx0, rxn);\n                right = Math.max(rx0, rxn);\n                break;\n            default:\n                break;\n        }\n\n        this.roadfits = true;\n        //Bounding rect\n        if (top < this.sim.size.y && bottom >= 0 && left >= 0 && right < this.sim.size.x) {\n            var road, rtop, rbottom, rleft, rright;\n            for (var i = 0; i < this.sim.roads.length; i++) {\n                road = this.sim.roads[i];\n                rtop = Math.max(road.dim.yd0, road.dim.yd0 + road.dim.dy);\n                rbottom = Math.min(road.dim.yd0, road.dim.yd0 + road.dim.dy);\n                rright = Math.max(road.dim.xd0, road.dim.xd0 + road.dim.dx);\n                rleft = Math.min(road.dim.xd0, road.dim.xd0 + road.dim.dx);\n                // l1 < r2 && r1 > l2 && b1 < t2 && t1 > b2\n                if (left < rright && right >= rleft && top >= rbottom && bottom < rtop) {\n                    this.roadfits = false;\n\n                    break;\n                }\n            }\n        } else {\n            this.roadfits = false;\n        }\n    }\n\n    insideRoad (x, y, road) {\n\n        var right = Math.max(road.dim.xn0, road.dim.xn0 + (road.o.lx * (road.lanes - 1)) + (road.o.px * (road.length - 1)));\n        var left = Math.min(road.dim.xn0, road.dim.xn0 + (road.o.lx * (road.lanes - 1)) + (road.o.px * (road.length - 1)));\n        var top = Math.max(road.dim.yn0, road.dim.yn0 + (road.o.ly * (road.lanes - 1)) + (road.o.py * (road.length - 1)));\n        var bottom = Math.min(road.dim.yn0, road.dim.yn0 + (road.o.ly * (road.lanes - 1)) + (road.o.py * (road.length - 1)));\n\n        return (x >= left)\n                && (x <= right)\n                && (y >= bottom)\n                && (y <= top);\n    }\n\n    insideInt (x, y, int) {\n        var right = int.base.x;\n        var left = int.base.x - 2 * int.lanes;\n        var bottom = int.base.y - 2 * int.lanes;\n        var top = int.base.y;\n        var ret = (x >= left)\n                && (x <= right)\n                && (y >= bottom)\n                && (y <= top);\n        return ret;\n    }\n\n    getPos (x, y, road) {\n        var lane, pos;\n        lane = Math.abs(road.o.lx * (road.dim.xn0 - x) + road.o.ly * (road.dim.yn0 - y));\n        //pos is distance in px/py from xn0/yn0\n        pos = Math.abs(road.o.px * (road.dim.xn0 - x) + road.o.py * (road.dim.yn0 - y));\n        return {l: lane, p: pos};\n    }\n};\n\nfunction Driver() {\n    return({NORMAL: 0, SLOW: 1, CRAZY: 2});\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputHandler);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/inputhandler.js?");

/***/ }),

/***/ "./src/js/traffic/intersection.js":
/*!****************************************!*\
  !*** ./src/js/traffic/intersection.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\n\n\n\nclass Intersection {\n    //Base point is the lower right corner on the grid, in grid units\n    constructor (basepoint, lanecount, type) {\n        this.base = {x: basepoint.x, y: basepoint.y};\n        this.lanes = lanecount;\n        this.type = type;\n        this.colors = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(7);\n\n        //Sides basically are in's and out's, 4 of um\n        this.outs = [];     //Point to roads\n        for (var i = 0; i < 4; i++) {\n            this.outs[i] = \"none\";\n        }\n\n        //Fields needed for managing logic.\n        this.timer = 0;\n        this.threshold = 200;\n        this.currentside = 0;   //Side 'in', same orientation as roads\n        this.cycle = 0;\n        this.outside = 1;\n\n        this.cars = [];\n        this.road = [];//Square road this time.  the side is a road, same as before\n        //Bottom right is 0,0, 'left turn' goes towards 2n,2n corner\n        for (var i = 0; i < this.lanes * 2; i++) {\n            this.road[i] = [];\n            for (var j = 0; j < this.lanes * 2; j++) {\n                this.road[i][j] = 0;\n            }\n        }\n    }\n\n    update() {\n        var side = this.currentside;\n        var out = (this.currentside + this.cycle + 1) % 4; \n        // console.log(this.cars);\n        //Only do stuff/allow cars in if there is an output that way.\n        if (this.outs[out] !== \"none\") {\n            for (var c = 0; c < this.cars.length; c++) {\n                var car = this.cars[c];\n                car.timer++;\n                if (car.timer > car.speed) {\n                    car.timer = 0;\n                    switch (this.cycle) {\n                        case 0:  //Right                            \n                            this.updateCarRight(car, c);\n                            break;\n                        case 1:  //Straight\n                            this.updateCarStraight(car, c);\n                            break;\n                        case 2:  //Left\n                            this.updateCarLeft(car, c);\n                            break;\n                        default:\n                            // console.log(\"hit default update for car in intersection.\");\n                            break;\n                    }\n                }\n            }\n        } else {\n            this.timer = this.threshold;\n        }\n\n        //Increment timer, and change stuff if necessary\n        this.timer++;\n        if ((this.timer >= this.threshold) && (this.cars.length === 0)) {\n            this.cycle = Math.floor(Math.random() * 3);\n            this.currentside = (this.currentside + 1) % 4;\n            this.outside = (this.currentside + this.cycle + 1) % 4;\n            this.timer = 0;\n\n            // console.log(\"changed state cs: \"+this.currentside+\" os: \"+this.outside);\n        }\n    }\n\n    draw (ctx, size) {\n        this.drawPavement(ctx, size);\n        this.drawCars(ctx, size);\n    }\n\n    drawPavement (ctx, size) {\n        //Grey square under the intersection\n        ctx.fillStyle = \"lightgrey\";\n        var x0 = (size.scale * (this.base.x + 1)) + size.x0;\n        var y0 = (size.scale * (this.base.y + 1)) + size.y0;\n        var d = -2 * size.scale * this.lanes;\n        ctx.beginPath();\n        ctx.rect(x0, y0, d, d);\n        ctx.fill();\n\n        ctx.strokeStyle = \"darkgrey\";\n        ctx.beginPath();\n        ctx.setLineDash([size.scale * this.lanes]);\n        ctx.lineWidth = 3;\n        ctx.rect(x0, y0, d, d);\n        ctx.stroke();\n        ctx.setLineDash([0]);\n    }\n\n    drawCars (ctx, size) {\n        //Need to draw cars based on road orientation.\n        var t = this.getDrawTransform(this.currentside);\n\n        //Transform array position to draw position\n        var cloc = {x: 0, y: 0};\n        for (var c = 0; c < this.cars.length; c++) {\n            var car = this.cars[c];\n            cloc.x = size.scale * ((this.base.x + t.dbasex * (2 * this.lanes - 1)) + t.lanex * car.loc.lane + t.posx * car.loc.pos) + size.x0;\n            cloc.y = size.scale * ((this.base.y + t.dbasey * (2 * this.lanes - 1)) + t.laney * car.loc.lane + t.posy * car.loc.pos) + size.y0;\n            ctx.beginPath();\n            ctx.fillStyle = this.colors.get(car.id);\n            ctx.fillRect(cloc.x+2,\n                    cloc.y+2,\n                    (size.scale-4),\n                    (size.scale-4));    \n        }\n    }\n\n    addCar (c, side) {\n        this.cars.push(c);\n        //Based on side, need to add car to right location.\n        var l, p;\n        var n = this.lanes;\n        var lane = c.loc.lane;\n        c.loc.pos = 0;\n        this.road[lane][0] = c;\n    }\n\n    setOutput (r, s) {\n        this.outs[s] = r;\n    }\n\n    updateCarStraight (car, c) {\n        var out = this.outs[this.outside];\n        if (car.loc.pos >= (this.lanes * 2 - 1)) {\n            this.passCar( out, car, car.loc.lane, c );\n        } else {\n            //Else, try to go straight\n            this.moveForward(car);\n        }\n    }\n\n    updateCarRight (car, c) {\n\n        var out = this.outs[this.outside];\n        // console.log(\"out\", out, \"cs\", this.currentside); \n\n        //Car goes straight until its in the diagonal, then right until out\n        //diagonal is when pos == lane\n        if (car.loc.lane === 0) {\n            this.passCar( out, car, car.loc.pos, c );\n        } else {\n            if (car.loc.pos >= car.loc.lane) {\n                this.moveRight(car);\n            } else {\n                //Else, try to go straight\n                this.moveForward(car);\n            }\n        }\n    }\n\n    updateCarLeft (car, c) {\n        var out = this.outs[this.outside];\n        if (car.loc.lane === 2 * this.lanes - 1) {\n            //Try to pass car to output\n            var laneout = (2 * this.lanes - 1 - car.loc.pos);\n            this.passCar( out, car, laneout, c );\n        } else {\n            if (car.loc.pos <= 2*this.lanes - car.loc.pos - car.loc.lane) {\n                this.moveForward(car);\n            } else {\n                this.moveLeft(car);\n            }\n        }\n    }\n\n    passCar (out, car, laneout, c) {\n        if (out.open(laneout, 0)) {\n            out.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_0__.default(car.id, {lane: laneout, pos: 0, speed: car.speed}, car.type));\n            this.cars.splice(c, 1);\n            this.road[car.loc.lane][car.loc.pos] = 0;\n        }\n    }\n\n    moveForward (car) {\n        if (this.road[car.loc.lane][car.loc.pos + 1] === 0) {\n            this.road[car.loc.lane][car.loc.pos] = 0;\n            this.road[car.loc.lane][car.loc.pos+1] = car;\n            car.loc.pos++;\n        } else {\n            car.timer = this.threshold;\n        }\n    }\n\n    moveRight (car) {\n        if (this.road[car.loc.lane-1][car.loc.pos ] === 0) {\n            this.road[car.loc.lane][car.loc.pos] = 0;\n            this.road[car.loc.lane-1][car.loc.pos] = car;\n            car.loc.lane--;\n        } else {\n            car.timer = this.threshold;\n        }\n    }\n\n    moveLeft (car) {\n        if (this.road[car.loc.lane+1][car.loc.pos ] === 0) {\n            this.road[car.loc.lane][car.loc.pos] = 0;\n            this.road[car.loc.lane+1][car.loc.pos] = car;\n            car.loc.lane++;\n        } else {\n            car.timer = this.threshold;\n        }\n    }\n\n    open (lane, side) {\n        //Need to use orientation of sides to do this in a less shitty way.\n        return ((side === this.currentside) && this.road[lane][0] === 0 && this.outs[this.outside] != \"none\");\n    }\n\n    getSide (mx, my) {\n        console.log(\"Inter getSide:\", mx, my);\n        //Given mouse click, see what side its on.\n        //whichever quadrant its in. \n        if (mx <= (this.base.x - this.lanes)) {\n            if (my <= (this.base.y - this.lanes)) {\n                return 0;\n            } else {\n                return 1;\n            }\n        } else {\n            if (my <= (this.base.y - this.lanes)) {\n                return 3;\n            } else {\n                return 2;\n            }\n        }\n    }\n\n    getOut (mx, my) {\n        if (mx <= (this.base.x - this.lanes)) {\n            if (my <= (this.base.y - this.lanes)) {\n                return 1;\n            } else {\n                return 2;\n            }\n        } else {\n            if (my <= (this.base.y - this.lanes)) {\n                return 0;\n            } else {\n                return 3;\n            }\n        }\n    }\n\n    getFrom (size, scale, side) {\n        //Need out location for line.\n        var xr, yr;\n        switch (side) {\n            case 0:\n                xr = (this.base.x - (0.5) * this.lanes + 1) * scale + size.x0;\n                yr = (this.base.y - (2) * this.lanes + 1.5) * scale + size.y0;\n                break;\n            case 1:\n                xr = (this.base.x - (2) * this.lanes + 1.5) * scale + size.x0;\n                yr = (this.base.y - (1.5) * this.lanes + 1) * scale + size.y0;\n                break;\n            case 2:\n                xr = (this.base.x - (1.5) * this.lanes + 1) * scale + size.x0;\n                yr = (this.base.y + 0.5) * scale + size.y0;\n                break;\n            case 3:\n                xr = (this.base.x + 0.5) * scale + size.x0;\n                yr = (this.base.y - (0.5) * this.lanes + 1) * scale + size.y0;\n                break;\n            default:\n                break;\n        }\n        return {\n            x: xr,\n            y: yr\n        };\n    }\n\n    getTo (size, scale, side) {\n        //Use side to find \n        var xr, yr;\n        switch (side) {\n            case 0:\n                xr = (this.base.x - (1.5) * this.lanes + 1) * scale + size.x0;\n                yr = (this.base.y - (2) * this.lanes + 1.5) * scale + size.y0;\n                break;\n            case 1:\n                xr = (this.base.x - (2) * this.lanes + 1.5) * scale + size.x0;\n                yr = (this.base.y - (0.5) * this.lanes + 1) * scale + size.y0;\n                break;\n            case 2:\n                xr = (this.base.x - (0.5) * this.lanes + 1) * scale + size.x0;\n                yr = (this.base.y + 0.5) * scale + size.y0;\n                break;\n            case 3:\n                xr = (this.base.x + 0.5) * scale + size.x0;\n                yr = (this.base.y - (1.5) * this.lanes + 1) * scale + size.y0;\n                break;\n            default:\n                break;\n        }\n        return {\n            x: xr,\n            y: yr\n        };\n    }\n\n    getO (o) {\n        switch (o) {\n            case 0:\n                return {x: -1, y: -1, xd: 1, yd: 1, lx: -1, ly: 0, px: 0, py: -1};\n                break;\n            case 1:\n                return {x: -1, y: 1, xd: 1, yd: 0, lx: 0, ly: 1, px: -1, py: 0};\n                break;\n            case 2:\n                return {x: 1, y: 1, xd: 0, yd: 0, lx: 1, ly: 0, px: 0, py: 1};\n                break;\n            case 3:\n                return {x: 1, y: -1, xd: 0, yd: 1, lx: 0, ly: -1, px: 1, py: 0};\n                break\n            default:\n\n        }\n    }\n\n    getDrawTransform (side) {\n        var ret;\n        switch (side) {\n            case 0:\n                ret = {\n                    dbasex: -1,\n                    dbasey: -1,\n                    lanex: 1,\n                    laney: 0,\n                    posx: 0,\n                    posy: 1\n                };\n                break;\n            case 1:\n                ret = {\n                    dbasex: -1,\n                    dbasey: 0,\n                    lanex: 0,\n                    laney: -1,\n                    posx: 1,\n                    posy: 0\n                };\n                break;\n            case 2:\n                ret = {\n                    dbasex: 0,\n                    dbasey: 0,\n                    lanex: -1,\n                    laney: 0,\n                    posx: 0,\n                    posy: -1\n                };\n                break;\n            case 3:\n                ret = {\n                    dbasex: 0,\n                    dbasey: -1,\n                    lanex: 0,\n                    laney: 1,\n                    posx: -1,\n                    posy: 0\n                };\n                break;\n            default:\n        }\n        return ret;\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Intersection);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/intersection.js?");

/***/ }),

/***/ "./src/js/traffic/road.js":
/*!********************************!*\
  !*** ./src/js/traffic/road.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\n\n\n\nclass Road {\n    //Roads track their 0lane, 0pos, lanes, length, and orientation\n    //TODO - make orientation not shitty.  Either enum like driver, or use explicit\n    //     - names in an input object that describe the orientation 'vectors' of the\n    //     - lane and position directions ex: {lanex: 0, laney: -1, posx: 1, posy: 0} \n    //     - orientation is a bunch of vectors that could probably be more simply\n    //     - expressed but w.e  it works right now. \n    constructor(rdata, orientation, length, lanes){\n\t    this.orientation = orientation;    // 0 iup (-y), 1 ileft(-x), 2 idown(+y), 3 iright(+x)\n\t    this.o = {x: 0, y: 0, xd: 0, yd: 0, lx: -1, ly: 0, lanes: lanes};\n\t    this.length = length;\n\t    this.lanes = lanes;\n\t    this.out = \"none\";   //Out is where cars are passed when they get to the end.\n\t    this.outside = 0;\n\t    this.outs = [];\n\t    this.outs[0] = \"none\";\n\n\t    this.colors = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(7);\n\n\t    this.start = {xn: rdata.x, yn: rdata.y, x: 0, y: 0};\n\n\t    this.dim = {\n\t        xn0: rdata.x,\n\t        yn0: rdata.y,\n\t        xd0: 0,\n\t        yd0: 0,\n\t        dx: 0,\n\t        dy: 0};\n\n\t    //Orientation and dimensions - makes drawing easier\n\t    this.o = this.getO(this.orientation);\n\n        console.log(this.orientation, this.o)\n\n\t    this.dim.xd0 = this.dim.xn0 + this.o.xd;\n\t    this.dim.yd0 = this.dim.yn0 + this.o.yd;\n\t    this.dim.dx = this.o.lx * this.lanes + this.o.px * this.length;\n\t    this.dim.dy = this.o.ly * this.lanes + this.o.py * this.length;\n\n\t    this.cars = [];\n\t    this.road = [];\n\t    for (var i = 0; i < lanes; i++) {\n\t        this.road[i] = [];\n\t        for (var j = 0; j < length; j++) {\n\t            this.road[i][j] = 0;\n\t        }\n\t    }\n\t}\n\t\n\tdraw(ctx, size) {\n        this.drawPavement(ctx, size);\n        this.drawCars(ctx, size);\n    }\n\n    update() {\n        //Update Cars\n        //If an update pushes a car to the intersection, it asks the\n        //intersection if it can proceed, if so, pass and then remove\n        var forward = 0, depass = 1, pass = 1, position = 0, car = 0;\n        for (var c = 0; c < this.cars.length; c++) {\n            car = this.cars[c];\n\n            if (car.timer++ > car.speed) {\n                car.timer = 0;\n                //If near end, do intersection shit\n                if (car.loc.pos === (this.length - 1) && this.out !== \"none\") {\n                    if (this.out.open(car.loc.lane, this.outside)) {\n                        this.out.addCar(new _car_js__WEBPACK_IMPORTED_MODULE_0__.default(car.id, {lane: car.loc.lane, pos: 0, speed: car.speed}, car.type), this.outside);\n                        this.cars.splice(c, 1);\n                        this.road[car.loc.lane][car.loc.pos] = 0;\n                    }\n                } else {\n                    switch (car.type) {\n                        case 0:\n                            //If you can depass, depass.\n                            if (car.loc.lane > 0) {\n                                depass = this.road[car.loc.lane - 1][ car.loc.pos + 1 ];\n                                if (depass === 0) {\n                                    this.depass(car);\n                                    return;\n                                }\n                            }\n                            //If forward is clear go, else pass\n                            forward = this.road[car.loc.lane + 0][car.loc.pos + 1];\n                            if (forward === 0) {\n                                this.moveForward(car);\n                                return;\n                            } else {\n                                if (car.loc.lane < (this.lanes - 1)) {\n                                    pass = this.road[car.loc.lane + 1][ car.loc.pos + 1 ];\n                                    if (pass === 0) {\n                                        //TODO - Pass function outta scope\n                                        this.pass(car);\n                                        return;\n                                    }\n                                }\n                            }\n                            break;\n                        // case Driver().CRAZY:\n                        //     break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    drawPavement(ctx, size) {\n        //Grey rectangle under the road\n        ctx.fillStyle = \"lightgrey\";\n        var x0 = (size.scale * (this.dim.xd0)) + size.x0;\n        var y0 = (size.scale * (this.dim.yd0)) + size.y0;\n        ctx.beginPath();\n        ctx.rect(x0,\n                y0,\n                size.scale * this.dim.dx,\n                size.scale * this.dim.dy);\n        ctx.fill();\n\n        //Outline the road\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.moveTo(x0, y0);\n        ctx.lineTo(x0 + (size.scale * this.o.px * this.length), y0 + (size.scale * this.o.py * this.length));\n        ctx.stroke();\n        ctx.beginPath();\n        var xl = 0, yl = 0;\n        xl = x0 + (size.scale * this.o.lx * this.lanes);\n        yl = y0 + (size.scale * this.o.ly * this.lanes);\n        ctx.moveTo(xl, yl);\n        ctx.lineTo(xl + (size.scale * this.o.px * this.length), yl + (size.scale * this.o.py * this.length));\n        ctx.stroke();\n\n        //Draw lane lines\n        if (this.lanes > 1) {\n            ctx.strokeStyle = \"darkgrey\";\n            ctx.lineWidth = 3;\n            var xp = 0, yp = 0;\n            for (var l = 1; l < (this.lanes); l++) {\n                xl = x0 + (size.scale * this.o.lx * l);\n                yl = y0 + (size.scale * this.o.ly * l);\n                for (var p = 0; p < this.length; p += 2) {\n                    xp = xl + (size.scale * this.o.px * p);\n                    yp = yl + (size.scale * this.o.py * p);\n                    ctx.beginPath();\n                    ctx.moveTo(xp, yp);\n                    ctx.lineTo(xp + (size.scale * this.o.px), yp + (size.scale * this.o.py));\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n\n    drawCars(ctx, size) {\n        var cloc = {x: 0, y: 0};\n        for (var c = 0; c < this.cars.length; c++) {\n            var car = this.cars[c];\n            cloc.x = size.scale * (this.dim.xd0 + (this.o.lx * car.loc.lane) + (this.o.px * car.loc.pos)) + size.x0;\n            cloc.y = size.scale * (this.dim.yd0 + (this.o.ly * car.loc.lane) + (this.o.py * car.loc.pos)) + size.y0;\n            ctx.beginPath();\n            ctx.fillStyle = this.colors.get(car.id);\n            ctx.fillRect(cloc.x + 2*(this.o.x),\n                    cloc.y+ 2*(this.o.y),\n                    (size.scale * (this.o.x) - 4*(this.o.x)),\n                    (size.scale * (this.o.y) - 4*(this.o.y)));\n        }\n    }\n\n    addCar(c) {\n        this.cars.push(c);\n        this.road[c.loc.lane][c.loc.pos] = c;\n    }\n\n    setOutput(r, s) {\n        this.out = r;\n        this.outs[0] = r;\n        this.outside = s;\n    }\n\n    depass(c) {\n        this.road[c.loc.lane][c.loc.pos] = 0;\n        c.loc.lane--;\n        c.loc.pos++;\n        this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n\n    moveForward(c) {\n        this.road[c.loc.lane][c.loc.pos] = 0;\n        c.loc.pos++;\n        this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n\n    pass(c) {\n        this.road[c.loc.lane][c.loc.pos] = 0;\n        c.loc.lane++;\n        c.loc.pos++;\n        this.road[c.loc.lane][c.loc.pos] = 1;\n    }\n\n    open(lane, s) {\n        return (this.road[lane][0] === 0);\n    }\n\n    add(c) {\n        this.cars.push(c);\n        var n = this.cars.length;\n        //this.cars[n - 1].loc = {lane: 0, pos: 0};\n        this.road[c.loc.lane][0] = c;\n    }\n\n    getFrom(size, scale, side) {\n        var xout, yout;\n        xout = (this.dim.xd0\n                + (this.length - 0.5) * this.o.px\n                + (this.lanes / 2) * this.o.lx) * scale\n                + size.x0;\n        yout = (this.dim.yd0\n                + (this.length - 0.5) * this.o.py\n                + (this.lanes / 2) * this.o.ly) * scale\n                + size.y0;\n        return {x: xout, y: yout};\n    }\n\n    getTo(size, scale, side) {\n        return {\n            x: (this.dim.xd0 + 0.5 * this.o.lx * this.lanes + this.o.px * (0.5)) * scale + size.x0,\n            y: (this.dim.yd0 + 0.5 * this.o.ly * this.lanes + this.o.py * (0.5)) * scale + size.y0\n        };\n    }\n\n    getO(o) {\n        switch (o) {\n            case 0:\n                return {x: -1, y: -1, xd: 1, yd: 1, lx: -1, ly: 0, px: 0, py: -1};\n                break;\n            case 1:\n                return {x: -1, y: 1, xd: 1, yd: 0, lx: 0, ly: 1, px: -1, py: 0};\n                break;\n            case 2:\n                return {x: 1, y: 1, xd: 0, yd: 0, lx: 1, ly: 0, px: 0, py: 1};\n                break;\n            case 3:\n                return {x: 1, y: -1, xd: 0, yd: 1, lx: 0, ly: -1, px: 1, py: 0};\n                break\n            default:\n\n        }\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Road);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/road.js?");

/***/ }),

/***/ "./src/js/traffic/simulation.js":
/*!**************************************!*\
  !*** ./src/js/traffic/simulation.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n/* harmony import */ var _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorpicker.js */ \"./src/js/traffic/colorpicker.js\");\n/* harmony import */ var _inputhandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputhandler.js */ \"./src/js/traffic/inputhandler.js\");\n\n\n\n\n/* TSimulation class that will run all the things\n * \n * ctx, world, units, logic, draw, loop\n * \n * @param {canvas element} canvas\n * @returns {TSimulation}\n */\nclass Simulation {\n\tconstructor(canvas){\n\t\tthis.canvas = canvas;\n\t\tthis.scale  = 12;\n\t\tthis.size   = this.getSize();\n\t\tthis.ctx    = this.canvas.getContext('2d');\n\t\tthis.roads  = [];\n\t\tthis.intersections = [];\n        \n\t\tthis.input = new _inputhandler_js__WEBPACK_IMPORTED_MODULE_2__.default(this);\n\t\tthis.color = new _colorpicker_js__WEBPACK_IMPORTED_MODULE_1__.default(10);\n\t}\n\n    run() {\n        var self = this;\n        var tick = function () {\n            self.update();\n            self.draw();\n            setTimeout(function () {\n                requestAnimationFrame(tick);\n            }, 1000 / self.fps);\n        };\n        tick(); //Start the show\n    }\n\n    update() {\n        var i;\n        //Update each road, update each intersection\n        for (i = 0; i < this.roads.length; i++) {\n            this.roads[i].update();\n        }\n        for (i = 0; i < this.intersections.length; i++) {\n            this.intersections[i].update();\n        }\n    }\n\n    draw() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.drawGrid();\n        var i;\n        //Draw each road, intersection\n        for (i = 0; i < this.roads.length; i++) {\n            this.roads[i].draw(this.ctx, this.size);\n        }\n        for (i = 0; i < this.intersections.length; i++) {\n            this.intersections[i].draw(this.ctx, this.size);\n        }\n        this.input.draw();\n    }\n\n    drawGrid() {\n        var crosssize = this.scale * 0.25;\n        var blanksize = this.scale - crosssize;\n\n        this.ctx.strokeStyle = \"black\";\n        this.ctx.lineWidth = 1;\n\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5);\n        this.ctx.lineTo((crosssize / 2) + this.size.x0 + 0.5, this.size.y0 + 0.5);\n        this.ctx.stroke();\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5);\n        this.ctx.lineTo(this.size.x0 + 0.5, (crosssize / 2) + this.size.y0 + 0.5);\n        this.ctx.stroke();\n\n        for (var i = 0; i < this.size.x + 1; i++) {\n            this.ctx.setLineDash([]);\n            this.ctx.beginPath();\n            this.ctx.moveTo(this.size.x0 + 0.5 + this.scale * i, this.size.y0 + 0.5);\n            this.ctx.lineTo(this.size.x0 + 0.5 + this.scale * i, this.size.y0 + 0.5 + (crosssize / 2));\n            this.ctx.stroke();\n\n            this.ctx.setLineDash([crosssize, blanksize]);\n            this.ctx.beginPath();\n            this.ctx.moveTo(i * this.scale + this.size.x0 + 0.5, this.size.y0 + 0.5 + blanksize + (crosssize / 2));\n            this.ctx.lineTo(i * this.scale + this.size.x0 + 0.5, this.size.y0 + this.size.h + 0.5);\n            this.ctx.stroke();\n        }\n        for (var j = 0; j < this.size.y + 1; j++) {\n            this.ctx.setLineDash([]);\n            this.ctx.beginPath();\n            this.ctx.moveTo(this.size.x0 + 0.5, this.size.y0 + 0.5 + this.scale * j);\n            this.ctx.lineTo(this.size.x0 + 0.5 + (crosssize / 2), this.size.y0 + 0.5 + this.scale * j);\n            this.ctx.stroke();\n\n            this.ctx.setLineDash([crosssize, blanksize]);\n            this.ctx.beginPath();\n            this.ctx.moveTo(this.size.x0 + 0.5 + blanksize + (crosssize / 2), j * this.scale + this.size.y0 + 0.5);\n            this.ctx.lineTo(this.size.x0 + this.size.w + 0.5, j * this.scale + this.size.y0 + 0.5);\n            this.ctx.stroke();\n        }\n        this.ctx.setLineDash([]);\n    }\n\n    getSize() {\n        //Return 0 point of drawing grid, width of grid in pixels/cells\n\n        const rect = this.canvas.getBoundingClientRect();\n        // const mx = event.clientX - rect.left\n        // const my = event.clientY - rect.top\n\n        var width = rect.width;\n        var height = rect.height;\n\n        // var width  = this.canvas.width;\n        // var height = this.canvas.height;\n        \n        var xn = Math.floor((width  - this.scale) / this.scale);\n        var yn = Math.floor((height - this.scale) / this.scale);\n\n        return {\n            x: xn,\n            y: yn,\n            w: xn * this.scale,\n            h: yn * this.scale,\n            x0: (width  - (xn * this.scale)) / 2,\n            y0: (height - (yn * this.scale)) / 2,\n            scale: this.scale\n        };\n    }\n\n    addRoad(r) {\n        this.roads.push(r);\n    }\n\n    addCar(r, c) {\n        var road = this.roads[r];\n        road.addCar(c);\n    }\n\n    addIntersection(i) {\n        this.intersections.push(i);\n    }\n\n    connectRoad(from, to) {\n        this.roads[from].setOutput(this.roads[to]);\n    }\n\n    connect(from, to) {\n        //Make it agnostic.  Intersections will be passed as int.side to differentiat sides\n        from.out = to;\n    }\n\n    connectRtoI( rfrom, intto, side ) {\n        this.roads[rfrom].setOutput( this.intersections[intto], side );\n    }\n\n    connectItoR( intfrom, rto, side ) {\n        this.intersections[intfrom].setOutput( this.roads[rto], side );\n    }\n\n    printStats(){\n        var str, r, inter;\n        str = \"\";\n        //Roads\n        for( var i = 0; i < this.roads.length; i++ ){\n            r = this.roads[i];\n            str += \" sim.addRoad( new Road({\";\n            str += \"x: \"+r.start.xn+\", y: \"+r.start.yn+\"},\";\n            str += r.orientation+\", \"+r.length+\", \"+r.lanes+\"));\\n\";\n        }\n        //Intersections\n        for( var i = 0; i < this.intersections.length; i++ ){\n            inter = this.intersections[i];\n            str += \" sim.addIntersection( new Intersection({\";\n            str += \"x: \"+inter.base.x+\", y: \"+inter.base.y+\"},\";\n            str += inter.lanes+\", 1));\\n\";\n        }\n        //Connections - Roads\n        for( var i = 0; i < this.roads.length; i++ ){\n            r = this.roads[i];\n            str += \" sim.addRoad( new Road({\";\n            str += \"x: \"+r.start.xn+\", y: \"+r.start.yn+\"},\";\n            str += r.orientation+\", \"+r.length+\", \"+r.lanes+\"));\\n\";\n        }\n        console.log( str );\n    }\n};\n\nfunction Driver() {\n    return({NORMAL: 0, SLOW: 1, CRAZY: 2});\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Simulation);\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/simulation.js?");

/***/ }),

/***/ "./src/js/traffic/traffic.js":
/*!***********************************!*\
  !*** ./src/js/traffic/traffic.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simulation.js */ \"./src/js/traffic/simulation.js\");\n/* harmony import */ var _road_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./road.js */ \"./src/js/traffic/road.js\");\n/* harmony import */ var _intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intersection.js */ \"./src/js/traffic/intersection.js\");\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./car.js */ \"./src/js/traffic/car.js\");\n// import '../style.css';\n\n\n\n\n\n// var canvas = $(\"#trafficcanvas\");\n\nvar canvas = document.getElementById('trafficcanvas');\n\n\nvar sim = new _simulation_js__WEBPACK_IMPORTED_MODULE_0__.default(canvas);\n\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 8, y: 20}, 0, 15, 2)); //0 - Up   (leftish)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 38, y: 20}, 0, 15, 2)); //1 - Up   (rightish)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 34, y: 21}, 1, 26, 2)); //2 - Left (lower)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 34,  y: 2}, 1, 26, 2)); //3 - Left (upper)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 5,  y: 6}, 2, 15, 2)); //4 - Down  (leftsh)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 35, y: 6}, 2, 15, 2));//5 - Down  (rightish)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 9, y: 24}, 3, 26, 2));//6 - Right (lower)\nsim.addRoad(new _road_js__WEBPACK_IMPORTED_MODULE_1__.default({x: 9, y: 5}, 3, 26, 2));//7 - Rght (uppwr)\n\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({x: 8, y: 5}, 2, 1));//0 (up left)\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({x: 38, y: 5}, 2, 1));//1 (up right)\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({x: 38, y: 24}, 2, 1));//2 (down right)\nsim.addIntersection(new _intersection_js__WEBPACK_IMPORTED_MODULE_2__.default({x: 8, y: 24}, 2, 1));//3 (down left)\n\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(0, {lane: 0, pos: 1, speed: 30}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(1, {lane: 0, pos: 5, speed: 50}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(2, {lane: 0, pos: 10, speed: 70}, 0));\nsim.addCar(0, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(3, {lane: 1, pos: 1, speed: 50}, 0));\n\nsim.addCar(4, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(4, {lane: 0, pos: 1, speed: 30}, 0));\n\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(8, {lane: 0, pos: 1, speed: 30}, 0));\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(9, {lane: 0, pos: 5, speed: 50}, 0));\nsim.addCar(5, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(10, {lane: 1, pos: 1, speed: 50}, 0));\n\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(11, {lane: 0, pos: 1, speed: 30}, 0));\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(12, {lane: 0, pos: 5, speed: 50}, 0));\nsim.addCar(6, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(13, {lane: 1, pos: 1, speed: 50}, 0));\n\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(14, {lane: 0, pos: 1, speed: 30}, 0));\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(15, {lane: 0, pos: 5, speed: 50}, 0));\nsim.addCar(7, new _car_js__WEBPACK_IMPORTED_MODULE_3__.default(16, {lane: 1, pos: 1, speed: 50}, 0));\n\n//Upperleft\nsim.connectRtoI(0, 0, 2);\nsim.connectRtoI(3, 0, 3);\nsim.connectItoR(0, 4, 2);\nsim.connectItoR(0, 7, 3);\n\n//Upperright\nsim.connectRtoI(1, 1, 2);\nsim.connectRtoI(7, 1, 1);\nsim.connectItoR(1, 3, 1);\nsim.connectItoR(1, 5, 2);\n\n//Lowerright\nsim.connectRtoI(6, 2, 1);\nsim.connectRtoI(5, 2, 0);\nsim.connectItoR(2, 1, 0);\nsim.connectItoR(2, 2, 1);\n\n//Lowerleft\nsim.connectRtoI(2, 3, 3);\nsim.connectRtoI(4, 3, 0);\nsim.connectItoR(3, 6, 3);\nsim.connectItoR(3, 0, 0);\n\nsim.run();\n\n//# sourceURL=webpack://powcraft/./src/js/traffic/traffic.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/traffic/traffic.js");
/******/ 	
/******/ })()
;